"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5229],{2544:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var o=r(4848),s=r(8453);const t={id:"parcels-api",title:"Parcels API",sidebar_label:"Parcels API"},l=void 0,a={id:"parcels-api",title:"Parcels API",description:"Most parcel methods will be called on the parcel itself, with the exception being around mounting.",source:"@site/versioned_docs/version-5.x/parcels-api.md",sourceDirName:".",slug:"/parcels-api",permalink:"/docs/5.x/parcels-api",draft:!1,unlisted:!1,editUrl:"https://github.com/single-spa/single-spa.js.org/blob/master/website/versioned_docs/version-5.x/parcels-api.md",tags:[],version:"5.x",frontMatter:{id:"parcels-api",title:"Parcels API",sidebar_label:"Parcels API"},sidebar:"docs",previous:{title:"Applications API",permalink:"/docs/5.x/api"},next:{title:"Overview",permalink:"/docs/5.x/ecosystem"}},i={},c=[{value:"mounting",id:"mounting",level:2},{value:"Parcel Props",id:"parcel-props",level:3},{value:"mountParcel",id:"mountparcel",level:3},{value:"mountRootParcel",id:"mountrootparcel",level:3},{value:"Parcel Object",id:"parcel-object",level:2},{value:"unmount",id:"unmount",level:3},{value:"mount",id:"mount",level:3},{value:"update",id:"update",level:3},{value:"getStatus",id:"getstatus",level:3},{value:"loadPromise",id:"loadpromise",level:3},{value:"bootstrapPromise",id:"bootstrappromise",level:3},{value:"mountPromise",id:"mountpromise",level:3},{value:"unmountPromise",id:"unmountpromise",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Most parcel methods will be called on the parcel itself, with the exception being around mounting."}),"\n",(0,o.jsx)(n.h2,{id:"mounting",children:"mounting"}),"\n",(0,o.jsxs)(n.p,{children:["Both mount methods take a ",(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-overview#parcel-configuration",children:"parcelConfig"})," and ",(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#parcel-props",children:"additional props"}),".\nThey both return a ",(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#parcel-object",children:"parcel object"}),". The parcel object contains all additional exposed methods."]}),"\n",(0,o.jsx)(n.h3,{id:"parcel-props",children:"Parcel Props"}),"\n",(0,o.jsx)(n.p,{children:"When mounting a parcel the second argument is props, a JavaScript object of properties to be passed to the parcel. This object must have a domElement prop, which is the dom node that the parcel will mount into."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const parcelProps = {\n  customerId: 7,\n  numberOfTasks: 42,\n  domElement: document.createElement("div"),\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"mountparcel",children:"mountParcel"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"applicationProps.mountParcel(parcelConfig, parcelProps)"}),". Each application is provided a mountParcel function.\nThe main advantage to using an applications ",(0,o.jsx)(n.code,{children:"mountParcel"})," function is that parcels mounted via an\napplications ",(0,o.jsx)(n.code,{children:"mountParcel"})," will be automatically unmounted when the application is unmounted."]}),"\n",(0,o.jsx)(n.p,{children:"The first argument may be either an object or a function that returns a promise that resolves with the object (a loading function)."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// Synchronous mounting\nconst parcel1 = applicationProps.mountParcel(parcelConfig, parcelProps);\n\n// Asynchronous mounting. Feel free to use webpack code splits or SystemJS dynamic loading\nconst parcel2 = applicationProps.mountParcel(\n  () => import("./some-parcel"),\n  parcelProps,\n);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"mountrootparcel",children:"mountRootParcel"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/docs/5.x/api#mountrootparcel",children:"mountRootParcel"})," method will mount the parcel but ",(0,o.jsx)(n.code,{children:"unmount"})," must be called manually."]}),"\n",(0,o.jsx)(n.h2,{id:"parcel-object",children:"Parcel Object"}),"\n",(0,o.jsx)(n.p,{children:"The parcel object contains the following functions and methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#mount",children:"mount"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#unmount",children:"unmount"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#update",children:"update"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#getstatus",children:"getStatus"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#loadpromise",children:"loadPromise"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#bootstrappromise",children:"bootstrapPromise"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#mountpromise",children:"mountPromise"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-api#unmountpromise",children:"unmountPromise"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"unmount",children:"unmount"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.unmount()"})," returns a promise that resolves once the parcel is successfully unmounted. The promise may throw an error which needs to be handled."]}),"\n",(0,o.jsx)(n.h3,{id:"mount",children:"mount"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.mount()"})," returns a promise that resolves once the parcel is successfully mounted. The promise can throw an error which needs to be handled."]}),"\n",(0,o.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.update(props)"})," allows you to change the props passed into a parcel. Note that not all parcels support being updated. The ",(0,o.jsx)(n.code,{children:"update"})," function returns a promise that resolves when the parcel is finished updating. See ",(0,o.jsx)(n.a,{href:"/docs/5.x/parcels-overview#update-optional",children:"other documentation"})," and ",(0,o.jsx)(n.a,{href:"https://single-spa.js.org/docs/parcels-overview.html#quick-example",children:"example"})," for more information."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const parcel = singleSpa.mountRootParcel(parcelConfig, parcelProps);\nparcel.update(newParcelProps);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getstatus",children:"getStatus"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.getStatus()"})," returns a string of that parcels status. The string status is one of the following:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NOT_BOOTSTRAPPED"}),": The parcel has not been bootstrapped"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BOOTSTRAPPING"}),": The parcel is bootstrapping but has not finished"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NOT_MOUNTED"}),": The parcel has bootstrapped, but is not mounted"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"MOUNTED"}),": The parcel is currently active and mounted to the DOM"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"UNMOUNTING"}),": The parcel is unmounting, but has not finished"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"UPDATING"}),": The parcel is currently being updated, but has not finished"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"SKIP_BECAUSE_BROKEN"}),": The parcel threw an error during bootstrap, mount, unmount, or update. Other parcels may continue normally, but this one will be skipped."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"loadpromise",children:"loadPromise"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.loadPromise()"})," returns a promise that will resolve once the parcel has been loaded."]}),"\n",(0,o.jsx)(n.h3,{id:"bootstrappromise",children:"bootstrapPromise"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.bootstrapPromise()"})," returns a promise that will resolve once the parcel has been bootstrapped."]}),"\n",(0,o.jsx)(n.h3,{id:"mountpromise",children:"mountPromise"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.mountPromise()"})," returns a promise that will resolve once the parcel has been mounted. This is helpful for knowing exactly when a parcel has been appended to the DOM"]}),"\n",(0,o.jsx)(n.h3,{id:"unmountpromise",children:"unmountPromise"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"parcel.unmountPromise()"})," returns a promise that will resolve once the parcel has been unmounted."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var o=r(6540);const s={},t=o.createContext(s);function l(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);