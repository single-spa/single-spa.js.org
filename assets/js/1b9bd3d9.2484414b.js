"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7745],{5587:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=s(4848),n=s(8453);const a={id:"module-types",title:"single-spa Microfrontend Types",sidebar_label:"Microfrontend Types"},o="Concept: single-spa Microfrontend Types",r={id:"module-types",title:"single-spa Microfrontend Types",description:"Single-spa has different categories of microfrontends. It is up to you where and how you use each of them. However, the single-spa core team has recommendations.",source:"@site/versioned_docs/version-5.x/module-types.md",sourceDirName:".",slug:"/module-types",permalink:"/docs/5.x/module-types",draft:!1,unlisted:!1,editUrl:"https://github.com/single-spa/single-spa.js.org/blob/master/website/versioned_docs/version-5.x/module-types.md",tags:[],version:"5.x",frontMatter:{id:"module-types",title:"single-spa Microfrontend Types",sidebar_label:"Microfrontend Types"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/5.x/microfrontends-concept"},next:{title:"Configuring single-spa",permalink:"/docs/5.x/configuration"}},l={},c=[{value:"Applications",id:"applications",level:2},{value:"Applications are declarative",id:"applications-are-declarative",level:3},{value:"Applications have managed lifecycles",id:"applications-have-managed-lifecycles",level:3},{value:"Applications and their public interface",id:"applications-and-their-public-interface",level:3},{value:"Parcels",id:"parcels",level:2},{value:"Parcels are imperative",id:"parcels-are-imperative",level:3},{value:"You manage the lifecycles of parcels",id:"you-manage-the-lifecycles-of-parcels",level:3},{value:"Parcels are best suited for sharing pieces of UI between frameworks",id:"parcels-are-best-suited-for-sharing-pieces-of-ui-between-frameworks",level:3},{value:"Utilities",id:"utilities",level:2},{value:"How do Utilites relate to single-spa?",id:"how-do-utilites-relate-to-single-spa",level:3},{value:"Utility modules share common logic",id:"utility-modules-share-common-logic",level:3},{value:"Examples of Utility Microfrontends",id:"examples-of-utility-microfrontends",level:3}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"concept-single-spa-microfrontend-types",children:"Concept: single-spa Microfrontend Types"}),"\n",(0,t.jsxs)(i.p,{children:["Single-spa has ",(0,t.jsx)(i.a,{href:"/docs/microfrontends-concept/#types-of-microfrontends",children:"different categories"})," of microfrontends. It is up to you where and how you use each of them. However, the single-spa core team has ",(0,t.jsx)(i.a,{href:"/docs/recommended-setup/#applications-versus-parcels-versus-utility-modules",children:"recommendations"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Here is how each single-spa microfrontend works conceptually. This information should help you understand our ",(0,t.jsx)(i.a,{href:"/docs/recommended-setup/#applications-versus-parcels-versus-utility-modules",children:"recommendations"}),"."]}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Topic"}),(0,t.jsx)(i.th,{children:"Application"}),(0,t.jsx)(i.th,{children:"Parcel"}),(0,t.jsx)(i.th,{children:"Utility"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Routing"}),(0,t.jsx)(i.td,{children:"has multiple routes"}),(0,t.jsx)(i.td,{children:"has no routes"}),(0,t.jsx)(i.td,{children:"has no routes"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"API"}),(0,t.jsx)(i.td,{children:"declarative API"}),(0,t.jsx)(i.td,{children:"imperative API"}),(0,t.jsx)(i.td,{children:"exports a public interface"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Renders UI"}),(0,t.jsx)(i.td,{children:"renders UI"}),(0,t.jsx)(i.td,{children:"renders UI"}),(0,t.jsx)(i.td,{children:"may or may not render UI"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Lifecycles"}),(0,t.jsx)(i.td,{children:"single-spa managed lifecycles"}),(0,t.jsx)(i.td,{children:"custom managed lifecycles"}),(0,t.jsx)(i.td,{children:"external module: no direct single-spa lifecycles"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"When to use"}),(0,t.jsx)(i.td,{children:"core building block"}),(0,t.jsx)(i.td,{children:"only needed with multiple frameworks"}),(0,t.jsx)(i.td,{children:"useful to share common logic, or create a service"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:["Each single-spa microfrontend is an in-browser JavaScript module (",(0,t.jsx)(i.a,{href:"/docs/recommended-setup#in-browser-versus-build-time-modules",children:"explanation"}),")."]}),"\n",(0,t.jsx)(i.h2,{id:"applications",children:"Applications"}),"\n",(0,t.jsx)(i.h3,{id:"applications-are-declarative",children:"Applications are declarative"}),"\n",(0,t.jsxs)(i.p,{children:["Applications use a declarative API called ",(0,t.jsx)(i.code,{children:"registerApplication"}),". Your single-spa config (also sometimes called the root config) defines applications ahead of time and defines the conditions for when each application is active, but it doesn't mount the applications directly."]}),"\n",(0,t.jsx)(i.h3,{id:"applications-have-managed-lifecycles",children:"Applications have managed lifecycles"}),"\n",(0,t.jsx)(i.p,{children:"single-spa manages registered applications and is in charge of all of their lifecycles. This prevents you from needing to write a bunch of logic about when applications should mount and unmount; single-spa takes care of that for you.\nAll that single-spa needs to make this work automatically is an activity function that describes when your application should be active."}),"\n",(0,t.jsx)(i.h3,{id:"applications-and-their-public-interface",children:"Applications and their public interface"}),"\n",(0,t.jsxs)(i.p,{children:["Applications ",(0,t.jsxs)(i.a,{href:"/docs/building-applications#registered-application-lifecycle",children:[(0,t.jsx)(i.em,{children:"must"})," export their lifecycles"]})," so they can be managed by single-spa, but they can also export additional methods, values, components, parcels, or more as part of their public interface. It is common to use these exports inside another application so you can create highly cohesive modules with low coupling."]}),"\n",(0,t.jsx)(i.h2,{id:"parcels",children:"Parcels"}),"\n",(0,t.jsx)(i.h3,{id:"parcels-are-imperative",children:"Parcels are imperative"}),"\n",(0,t.jsx)(i.p,{children:"Parcels exist in many ways as an escape hatch from the normal declarative flow. They exist primarily to allow you to reuse pieces of UI across applications when those applications are written in multiple frameworks."}),"\n",(0,t.jsx)(i.h3,{id:"you-manage-the-lifecycles-of-parcels",children:"You manage the lifecycles of parcels"}),"\n",(0,t.jsxs)(i.p,{children:["When you call ",(0,t.jsx)(i.code,{children:"mountParcel"})," or ",(0,t.jsx)(i.code,{children:"mountRootParcel"})," ",(0,t.jsx)(i.a,{href:"/docs/parcels-api",children:"(see API)"})," the parcel is mounted immediately and returns the parcel object. You need to call the ",(0,t.jsx)(i.code,{children:"unmount"})," method on the parcel manually when the component that calls ",(0,t.jsx)(i.code,{children:"mountParcel"})," unmounts."]}),"\n",(0,t.jsx)(i.h3,{id:"parcels-are-best-suited-for-sharing-pieces-of-ui-between-frameworks",children:"Parcels are best suited for sharing pieces of UI between frameworks"}),"\n",(0,t.jsxs)(i.p,{children:["Creating a parcel is as easy as using the ",(0,t.jsx)(i.a,{href:"/docs/ecosystem#help-for-frameworks",children:"single-spa helpers"})," for that framework on a specific component/UI. This returns an object (",(0,t.jsx)(i.code,{children:"parcelConfig"}),") that single-spa can use to create and mount a parcel.\nBecause single-spa can mount a parcel anywhere, this gives you a way to share UI/components across frameworks. It should not be used if the shared UI is being used in another application of the same framework.\nFor example: ",(0,t.jsx)(i.code,{children:"application1"})," is written in Vue and contains all the UI and logic to create a user. ",(0,t.jsx)(i.code,{children:"application2"})," is written in React and needs to create a user. Using a single-spa parcel allows you to wrap your ",(0,t.jsx)(i.code,{children:"application1"})," Vue component\nin a way that will make it work inside ",(0,t.jsx)(i.code,{children:"application2"})," despite the different frameworks.\nThink of parcels as a single-spa specific implementation of webcomponents."]}),"\n",(0,t.jsx)(i.h2,{id:"utilities",children:"Utilities"}),"\n",(0,t.jsx)(i.h3,{id:"how-do-utilites-relate-to-single-spa",children:"How do Utilites relate to single-spa?"}),"\n",(0,t.jsx)(i.p,{children:"A utility is an in-browser module that (generally) has it's own repository and CI process. It exports a public interface of functions and variables that any other microfrontend can import and use. A utility microfrontend is just like any other microfrontend, except it doesn't serve as a single-spa application or parcel."}),"\n",(0,t.jsx)(i.h3,{id:"utility-modules-share-common-logic",children:"Utility modules share common logic"}),"\n",(0,t.jsxs)(i.p,{children:["Utility modules are a great place to share common logic. Instead of each application creating their own implementation of common logic, you can use a plain JavaScript object (single-spa utility) to share that logic.\nFor example: Authorization. How does each application know which user is logged in? You could have each application ask the server or read a JWT but that creates duplicate work in each application.\nUsing the utility module pattern would allow you to create one module that implements the authorization logic. This module would export any needed methods, and then your other single-spa applications could use those authorization methods by importing them.\nThis approach also works well for data ",(0,t.jsx)(i.a,{href:"/docs/recommended-setup#api-data",children:"fetching"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"examples-of-utility-microfrontends",children:"Examples of Utility Microfrontends"}),"\n",(0,t.jsx)(i.p,{children:"The following are commonly implemented as a Utility Microfrontend:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Notification service"}),"\n",(0,t.jsx)(i.li,{children:"Styleguide/component library"}),"\n",(0,t.jsx)(i.li,{children:"Error tracking service"}),"\n",(0,t.jsx)(i.li,{children:"Authorization service"}),"\n",(0,t.jsx)(i.li,{children:"Data fetching"}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>r});var t=s(6540);const n={},a=t.createContext(n);function o(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);