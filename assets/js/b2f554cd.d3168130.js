"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3513],{3661:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2024/03/18/top-5-microfrontend-hosting-solutions","metadata":{"permalink":"/blog/2024/03/18/top-5-microfrontend-hosting-solutions","source":"@site/blog/2024-03-18-top-5-microfrontend-hosting-solutions.md","title":"Top 5 Microfrontend Hosting Solutions","description":"With rapid growth in recent years, microfrontends have become a popular solution with many companies, from large software organizations to small independent dev teams. Microfrontend hosting can get complicated quickly but it is a crucial aspect of scaling software organizations\' development cycle. Whether companies are using single-spa, module federation, or any other microfrontends tools, the management of CI/CD pipelines, deployments, CDNs, and service discovery is something all companies will have to solve.","date":"2024-03-18T00:00:00.000Z","formattedDate":"March 18, 2024","tags":[],"readingTime":7.18,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Top 5 Microfrontend Hosting Solutions"},"unlisted":false,"nextItem":{"title":"March 2024 Core Team Meeting","permalink":"/blog/2024/03/12/core-team-meeting-notes"}},"content":"With rapid growth in recent years, microfrontends have become a popular solution with many companies, from large software organizations to small independent dev teams. Microfrontend hosting can get complicated quickly but it is a crucial aspect of scaling software organizations\' development cycle. Whether companies are using single-spa, module federation, or any other microfrontends tools, the management of CI/CD pipelines, deployments, CDNs, and service discovery is something all companies will have to solve.\\n\\nSo what\u2019s the most effective solution? Because microfrontend hosting is a relatively new space, most companies have a hard time knowing where to start. Fortunately, there are very good options out there, and unless you have a good reason to, you don\u2019t have to build it out yourself. Here you\u2019ll find a list of the best hosting solutions and the important factors you\u2019ll need to consider to make the decision.\\n\\n## Server-side versus client-side rendering\\n\\nThis article focuses on hosting solutions for client-side rendered microfrontends, since the majority of microfrontend implementations rely solely on [client-side rendering](https://ferie.medium.com/what-is-the-client-side-rendering-and-how-it-works-c90210e2cd14).\\n\\n[Server-side rendering](https://www.heavy.ai/technical-glossary/server-side-rendering) of microfrontends often involves one or more docker containers that run [NodeJS](https://en.wikipedia.org/wiki/Node.js) to render [React](https://en.wikipedia.org/wiki/React_(software)), [Angular](https://en.wikipedia.org/wiki/Angular_(web_framework)), or [Vue](https://en.wikipedia.org/wiki/Vue.js) applications. For optimal performance, [single-spa server rendering](/docs/ssr-overview) also supports a single NodeJS runtime (rather than network requests between docker containers).\\n\\nIf your organization uses server-side rendering, the following rankings will still apply but may require some additional consideration that isn\u2019t covered here. \\n\\n## Low-level vs high-level hosting solutions\\n\\nHosting microfrontends can be accomplished with lower-level cloud services (AWS, GCP, Azure, etc) or via microfrontend-specific cloud hosting solutions such as Baseplate Cloud and Zephyr Cloud. Lower-level services may be more affordable but require much more initial setup and ongoing maintenance. Higher-level microfrontend hosting solutions provide targeted features to streamline the hosting and development process.\\n\\nCompanies who wish for sensible defaults and a straightforward implementation path may choose higher-level hosting solutions to save on DevOps and system admin costs. The additional built-in features of higher-level hosting solutions often reduce implementation time for companies migrating to or starting with microfrontends.\\n\\n## Solution comparison\\n\\n|                    | [Baseplate Cloud](https://baseplate.cloud) | [Zephyr Cloud](https://zephyr-cloud.io/) | [S3 + Cloudfront](https://aws.amazon.com/blogs/networking-and-content-delivery/amazon-s3-amazon-cloudfront-a-match-made-in-the-cloud/) | [GCP Storage + Cloud CDN](https://cloud.google.com/cdn/docs/overview) | [Azure Storage + CDN](https://learn.microsoft.com/en-us/azure/cdn/cdn-create-a-storage-account-with-cdn) |\\n| ------------ | ---------------- | ----------- | --------- | --------- | ----- |\\n| Global availability | \u2713 (via Cloudflare) | \u2713 (Cloudflare / Netlify) | \u2713 | \u2713 | \u2713 |\\n| Web app hosting <sup>1</sup> | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 |\\n| Environments support <sup>2</sup> | \u2713 | \u2713 | (manual) | (manual) | (manual) |\\n| Autogenerated CI pipelines <sup>3</sup> | \u2713 | (planned)  | \u2717 | \u2717 | \u2717 |\\n| Automated microfrontend creation | \u2713 (via API and CLI) | \u2713 | (manual) | (manual) | (manual) |\\n| Custom domains | \u2713 (via DNS records) | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 |\\n| Route / layout management <sup>4</sup> | \u2713 ([single-spa-layout template](/docs/layout-definition)) | (manual) | (manual) | (manual) | (manual) | (manual) |\\n| Self-owned assets storage <sup>5</sup> | \u2713 (optional bring-your-own-s3-bucket) | \u2713 | \u2713 | \u2713 | \u2713 |\\n| Edge-side HTML rendering optimizations <sup>6</sup> | \u2713 | (planned) | \u2717 | \u2717 | \u2717 |\\n| Service discovery <sup>7</sup> | \u2713 | \u2713 | (manual) | (manual) | (manual) |\\n| CORS / CSP / Cache Control | \u2713 (sensible defaults, fully customizable) | (planned)  | \u2713 | \u2713 | \u2713 |\\n| Usage metrics | \u2713 | (planned) | (manual) | (manual) | (manual) |\\n| Full audit trail <sup>8</sup> | \u2713 | \u2713 | (manual) | (manual) | (manual) |\\n| Permissions management | \u2713 (comprehensive, including microfrontend ownership) | \u2713 | \u2713 | \u2713 | \u2713 |\\n| Shared dependency management <sup>9</sup> | (planned) | \u2713 | (manual) | (manual) | (manual) |\\n| Server rendering support | (planned) | (planned) | \u2717 | \u2717 | \u2717 |\\n| Microfrontend marketplace <sup>10</sup> | (planned) | (planned) | \u2717 | \u2717 | \u2717 |\\n| Rolling deployments <sup>11</sup> | (planned) | (planned) | \u2717 | \u2717 | \u2717 |\\n\\n1. *Web apps hosting* refers to hosting the parent/root HTML file that initializes the microfrontends necessary for client-side rendering.\\n2. *Environment support* refers to hosting each microfrontend and web app on both internal test environments and live production environments. CI/CD Pipelines are configured to deploy to environments sequentially.\\n3. *Auto-generated CI pipelines* refers to generating configuration files for [Github workflow](https://docs.github.com/en/actions/using-workflows), [Azure Pipelines](https://azure.microsoft.com/en-us/products/devops/pipelines), [Gitlab CI](https://docs.gitlab.com/ee/ci/) and other CI/CD tools.\\n4. *Route / layout management* refers to managing the in-browser URL routes and DOM layout for microfrontends.\\n5. *Self-owned assets storage* refers to JS, CSS, HTML, font, and image files being stored within a bucket owned by the company implementing microfrontends, rather than by cloud hosting service.\\n6. *Edge-side HTML rendering optimizations* refers to dynamically changing the HTML file for a web app via code that runs in [edge locations](https://www.macrometa.com/articles/what-is-edge-side-rendering). Since edge locations are physically closer to most users than an origin server, this provides maximum performance beneifts. Performance benefits include inlining import maps, `<link rel=preload>`, and `<script>` elements so that the browser begins downloading the necessary resources for the current URL as quickly as possible.\\n7. *Service discovery* refers to all available microfrontends easily cross-communicating with each other. This is often done via [import maps](https://github.com/WICG/import-maps) or other manifest files.\\n8. *Full audit trail* refers to logs for all deployments, infrastructure changes, and configuration changes within the microfrontends system.\\n9. *Shared dependency management* refers to externalizing or federating shared npm packages between microfrontends, to improve performance by only downloading and executing the code for them once within a web page.\\n10. *Microfrontend marketplace* refers to purchasing or installing pre-made microfrontends into a company\'s system.\\n11. *Rolling deployments* refers to introducing new code changes to a microfrontend to only a fraction of the userbase, to minimize impact of releasing bad code.\\n\\n\\n## 1. Baseplate Cloud\\n\\n[Baseplate Cloud](https://baseplate.cloud/) tops the list for its ease of use and specific focus on single-spa hosting. Because it was made by the creator of single-spa, Baseplate\'s features have been informed by years of microfrontend and single-spa consultancies, making it the easiest microfrontend hosting choice for single-spa. Everything about the product simplifies and automates as much of the complexity as possible, and it\u2019s hard to find advantages in other solutions that beat this fact. Baseplate will probably be the best choice for any company that is prioritizing a streamlined cloud hosting experience.\\n\\nBaseplate\'s feature set automates the job functions of multiple software developers and frees up a lot of development resources without increasing the size of the development team. This easily offsets the cost of Baseplate\'s services.\\n\\nBaseplate supports the following features:\\n\\n- Web apps hosting\\n- Custom domains for web apps and static assets\\n- Unlimited deployable environments\\n- Unlimited microfrontends\\n- Autogenerated CI/CD pipelines\\n- Full audit trail\\n- Microfrontend-specific usage metrics\\n- CORS, CSP, and Cache-Control configuration\\n- Edge-side performance optimizations\\n\\nAlso of note, [Baseplate CDN](https://baseplate.cloud/docs/cdn/assets) is a source-available [Cloudflare worker](https://developers.cloudflare.com/workers/) designed for maximum performance and best practices. It is globally available at all [Cloudflare edge locations](https://www.cloudflare.com/network/).\\n\\n## 2. Zephyr Cloud\\n\\nFrom the creators of Module Federation, [Zephyr Cloud](https://zephyr-cloud.io/) is the premier hosting solution for module-federation-based microfrontends. It is currently in closed alpha with little publicly documented about its features.\\n\\n## 3. AWS S3 + Cloudfront\\n\\nAmazon Web Services (AWS) offers the low-level cloud services necessary for companies to set up a microfrontends hosting solution. The most common microfrontends hosting solution within AWS often involves a [Cloudflare distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview.html) that acts as a public [CDN](https://en.wikipedia.org/wiki/Content_delivery_network), with a private [S3 bucket](https://aws.amazon.com/s3/) as the origin containing all static web files (Javascript, CSS, HTML) needed.\\n\\nThe advantage of using lower-level cloud hosting services is their initial lower costs\u2014however, that comes at the expense of increased setup and maintenance complexity compared to microfrontend-specific cloud hosting solutions.\\n\\nImplementation details will vary from company to company. It\'s common for each microfrontend\'s files to be stored within a (virtual) folder within the s3 bucket and the manifest or import map listing all microfrontends made available in a JSON file. Web apps using the microfrontends may have their own S3 bucket or be within the same S3 bucket.\\n\\n## 4. GCP Storage + Cloud CDN\\n\\nGoogle Cloud Platform provides equivalent low-level cloud services to AWS. The same technical details that apply to AWS S3 + Cloudfront also apply to [GCP Cloud Storage](https://cloud.google.com/storage?hl=en) and [GCP Cloud CDN](https://cloud.google.com/cdn/docs/overview).\\n\\n## 5. Azure Storage + CDN\\n\\nAzure Storage provides equivalent low-level cloud services to AWS. The same technical details that apply to AWS S3 + Cloudfront also apply to [Azure Storage](https://azure.microsoft.com/en-us/products/category/storage) and [GCP Cloud CDN](https://azure.microsoft.com/en-us/products/cdn)."},{"id":"/2024/03/12/core-team-meeting-notes","metadata":{"permalink":"/blog/2024/03/12/core-team-meeting-notes","source":"@site/blog/2024-03-12-core-team-meeting-notes.md","title":"March 2024 Core Team Meeting","description":"Attendees: Joel Denning, Milan Kovacic","date":"2024-03-12T00:00:00.000Z","formattedDate":"March 12, 2024","tags":[],"readingTime":1.685,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Top 5 Microfrontend Hosting Solutions","permalink":"/blog/2024/03/18/top-5-microfrontend-hosting-solutions"},"nextItem":{"title":"February 2024 Core Team Meeting","permalink":"/blog/2024/02/14/core-team-meeting-notes"}},"content":"Attendees: Joel Denning, Milan Kovacic\\n\\nDate: 2024-03-13\\n\\n## Meeting Agenda\\n\\n- Typescript migration: single-spa@7 - typescript, IE11, navigation cancelation\\n- Migration from SystemJS to native modules - use es-module-shims??\\n- Discuss creation of single-spa CLI\\n- Getting started documentation being updated by Milan\\n- Discuss future of shared dependency management\\n\\n### TypeScript Migration\\n\\nFifth typescript PR has been merged (https://github.com/single-spa/single-spa/pull/1202). Sixth one on the way\\n\\n### Migration to native modules\\n\\nDiscuss the limitations of native modules and import maps (external import maps, external import maps, etc). Discuss whether to use [import-map-injector](https://github.com/single-spa/import-map-injector) or [es-module-shims](https://github.com/guybedford/es-module-shims) or neither. Joel expressed concern about runtime parsing of modules, but Milan pointed out that Ruby on Rails as adopted es-module-shims. We looked at the performance benchmarks for es-module-shims, which show it\'s only a 5ms difference compared to native modules.\\n\\nWe also discussed possible collaboration with Zack Jackson on module federation\'s new runtime (called MFP) and whether that could help. Also discuss whether a [service worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) would be necessary or helpful to hook into the browser\'s loading of modules.\\n\\n### single-spa CLI\\n\\nSee [single-spa issue 1205](https://github.com/single-spa/single-spa/issues/1205) for Milan\'s proposal. Joel has hesitations about abstracting away bundler config and configuration files, but we decided to proceed with Milan\'s proposal, since developer experience is one of the main barriers to entry for developers and corporations who are used to managed configuration in other projects (NextJS, Vite, etc etc). The main concern is how to do it in a way where single-spa users don\'t have to go digging in node_modules regularly to be able to do what they need to do to their projects.\\n\\n### Shared dependencies management\\n\\nBaseplate Cloud plans to use [JSPM CDN](https://jspm.org/cdn/jspm-io) for native ES module shared dependencies. Managing the dependencies in the import map over time is important to do in a sensible way that avoids accidentally breaking production, while still allowing for incremental migration of dependencies on microfrontend at a time.\\n\\nWe didn\'t decide on anything concrete - just brainstormed solutions. Ideally the open source ecosystem can self-host shared dependencies as well."},{"id":"/2024/02/14/core-team-meeting-notes","metadata":{"permalink":"/blog/2024/02/14/core-team-meeting-notes","source":"@site/blog/2024-02-14-core-team-meeting-notes.md","title":"February 2024 Core Team Meeting","description":"Attendees: Joel Denning, Milan Kovacic, Ian Bacher, Jake Hayes","date":"2024-02-14T00:00:00.000Z","formattedDate":"February 14, 2024","tags":[],"readingTime":0.745,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"March 2024 Core Team Meeting","permalink":"/blog/2024/03/12/core-team-meeting-notes"},"nextItem":{"title":"January 2024 Core Team Meeting","permalink":"/blog/2024/01/03/core-team-meeting-notes"}},"content":"Attendees: Joel Denning, Milan Kovacic, Ian Bacher, Jake Hayes\\n\\n## Meeting Agenda\\n\\n- TypeScript migration\\n  - single-spa\\n  - single-spa-react\\n- Maintenance update\\n- Baseplate\\n- Roadmap items\\n- Blog posts\\n\\n### TypeScript Migration\\n\\n1. Single-spa-layout broken types\\n2. New PR for migration [Single-spa](https://github.com/single-spa/single-spa/pull/1196)\\n\\n### Review other PR\'s\\n\\n1. Examination of an open [PR](https://github.com/single-spa/single-spa/pull/1189) to fix [Issue #1184](https://github.com/single-spa/single-spa/issues/1184)\\n   1. Discussed introducing a new [potential lifecycle hook](https://github.com/single-spa/single-spa/issues/1197)\\n\\n### Baseplate Pricing Feedback\\n\\n- Maybe indicate that GB storage is optional. It\'s possible to bring your own\\n- \\"The prices are not ridiculous\\" - Ian\\n- \\"The prices seem reasonable, and the descriptions make sense\\" - Jake\\n\\n### Roadmap Items\\n\\n- Removing default exports\\n- single-spa-playground was broken due to DNS records, Joel was able to fix that last week\\n- Look into CORS for single-spa-playground - @Ian will look into\\n\\n### Blog posts\\n\\n- Potentially adding Baseplate specific blog posts to single-spa"},{"id":"/2024/01/03/core-team-meeting-notes","metadata":{"permalink":"/blog/2024/01/03/core-team-meeting-notes","source":"@site/blog/2024-01-03-core-team-meeting-notes.md","title":"January 2024 Core Team Meeting","description":"Attendees: Joel Denning Jake Hayes, Milan Kovacic","date":"2024-01-03T00:00:00.000Z","formattedDate":"January 3, 2024","tags":[],"readingTime":0.78,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"February 2024 Core Team Meeting","permalink":"/blog/2024/02/14/core-team-meeting-notes"},"nextItem":{"title":"December 2023 Core Team Meeting","permalink":"/blog/2023/12/12/core-team-meeting-notes"}},"content":"Attendees: Joel Denning Jake Hayes, Milan Kovacic\\n\\n## Achievements and Progress from December\\n\\n- Opened https://github.com/single-spa/create-single-spa/pull/393 to address create-single-spa dependencies\\n\\n## January 2024 Roadmap\\n\\n1. Migrate main `single-spa` project to typescript. See [issue 1185](https://github.com/single-spa/single-spa/issues/1185), [PR 1186](https://github.com/single-spa/single-spa/pull/1186) and [PR 1187](https://github.com/single-spa/single-spa/pull/1187).\\n2. Continue work on the consolidation and updates of the example projects\\n3. Review https://github.com/single-spa/create-single-spa/pull/393\\n\\n## Meeting Notes\\n\\n- Reviewed Typescript pull requests ([PR 1186](https://github.com/single-spa/single-spa/pull/1186) and [PR 1187](https://github.com/single-spa/single-spa/pull/1187))\\n- Discuss and update roadmap\\n- Baseplate Cloud update\\n- Review and comment on https://github.com/single-spa/single-spa/issues/1184\\n- Review https://github.com/single-spa/single-spa-react/issues/164\\n\\n## Initiatives and Goals\\n\\n- Adding unit tests to existing projects\\n- SystemJS -> ESM migration\\n- create-single-spa update (https://github.com/cruft/cruft)\\n- Release single-spa 6 as latest \u2705\\n- Improve shared dependencies management\\n- Autopublishes to npm\\n- Server rendering enhancements?\\n- Support for NextJS, NuxtJS, Remix, create-react-app, and other build tools\\n- Consolidate example projects \ud83d\udea7\\n- Feature voting\\n- Automated integration tests for popular frameworks\\n- Update create-single-spa dependencies \ud83d\udea7"},{"id":"/2023/12/12/core-team-meeting-notes","metadata":{"permalink":"/blog/2023/12/12/core-team-meeting-notes","source":"@site/blog/2023-12-12-core-team-meeting-notes.md","title":"December 2023 Core Team Meeting","description":"Attendees: Artur Androsovych, Ian Bacher, Jake Hayes, Milan Kovacic","date":"2023-12-12T00:00:00.000Z","formattedDate":"December 12, 2023","tags":[],"readingTime":0.725,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"January 2024 Core Team Meeting","permalink":"/blog/2024/01/03/core-team-meeting-notes"},"nextItem":{"title":"single-spa 6","permalink":"/blog/2023/11/27/single-spa-6"}},"content":"Attendees: Artur Androsovych, Ian Bacher, Jake Hayes, Milan Kovacic\\n\\n## Achievements and Progress from November\\n\\n- Successfully released single-spa version 6, marking a significant milestone in the project\'s development\\n\\n## December 2023 Roadmap\\n\\n1. Update dependencies, and set up automation, starting with create-single-spa\\n2. Continue work on the consolidation and updates of the example projects\\n\\n## Meeting Notes\\n\\n- Welcomed Ian Bacher as a new addition to the core team.\\n- Reviewed single-spa roadmap\\n\\n## Initiatives and Goals\\n\\n- Adding unit tests to existing projects\\n- SystemJS -> ESM migration\\n- create-single-spa update (https://github.com/cruft/cruft)\\n- Release single-spa 6 as latest \u2705\\n- Improve shared dependencies management\\n- Autopublishes to npm\\n- Server rendering enhancements?\\n- Support for NextJS, NuxtJS, Remix, create-react-app, and other build tools\\n- Consolidate example projects \ud83d\udea7\\n- Feature voting\\n- Automated integration tests for popular frameworks\\n- Update create-single-spa dependencies \ud83d\udea7"},{"id":"/2023/11/27/single-spa-6","metadata":{"permalink":"/blog/2023/11/27/single-spa-6","source":"@site/blog/2023-11-27-single-spa-6.md","title":"single-spa 6","description":"We have released single-spa@6! The single-spa core team is committed to a stable single-spa runtime with very few breaking changes. We expect over 95% of single-spa users can upgrade easily without altering their changes!","date":"2023-11-27T00:00:00.000Z","formattedDate":"November 27, 2023","tags":[],"readingTime":9.505,"hasTruncateMarker":false,"authors":[{"name":"Joel Denning","url":"https://x.com/joelbdenning","imageURL":"https://avatars2.githubusercontent.com/u/5524384?s=460&v=4"}],"frontMatter":{"title":"single-spa 6","author":"Joel Denning","authorURL":"https://x.com/joelbdenning","authorImageURL":"https://avatars2.githubusercontent.com/u/5524384?s=460&v=4"},"unlisted":false,"prevItem":{"title":"December 2023 Core Team Meeting","permalink":"/blog/2023/12/12/core-team-meeting-notes"},"nextItem":{"title":"November 2023 Core Team Meeting","permalink":"/blog/2023/11/07/core-team-meeting-notes"}},"content":"We have released single-spa@6! The single-spa core team is committed to a stable single-spa runtime with very few breaking changes. We expect over 95% of single-spa users can upgrade easily without altering their changes!\\n\\n## Note from single-spa\'s creator\\n\\nOn September 22, 2015, I pushed single-spa\'s [initial commit](https://github.com/single-spa/single-spa/commit/1b885d783fde8000489cf19fc4db8e167aa55526). 8 years later, I am releasing single-spa@6. I am committed to this project and hope to improve and grow it for many years to come. The single-spa core team recently started monthly calls where we discuss important pull requests and roadmap (see first [meeting notes](https://single-spa.js.org/blog/2023/11/07/core-team-meeting-notes)). The future of microfrontends still includes single-spa.\\n\\nOn December 11, 2023, the company I founded is launching a product called [Baseplate Cloud](https://baseplate.cloud) that offers single-spa hosting. Baseplate Cloud is the single-spa hosting solution born from 4+ years of consulting with various companies who were implementing single-spa. [Baseplate CDN](https://baseplate.cloud/docs/cdn/intro) is a Cloudflare worker that proxies JS files from cloud storage, provides edge-side import map processing, auto-implements single-spa root configs, and more. Cloudflare edge-side processing provides many performance advantages while retaining the impressive scalability and security of Cloudflare. As a sign of good will towards the open source and single-spa communities, I have kept the [baseplate-cloudflare-worker](https://github.com/JustUtahCoders/baseplate-cloudflare-worker) public, with a \\"Commons Clause\\" + AGPL 3.0 license. Companies can use and contribute to baseplate-cloudflare-worker freely, as long as they don\'t try to sell it in competition to Baseplate Cloud. I would appreciate the community\'s backing and hope Baseplate becomes the way to financially sustain the single-spa project in the long term.\\n\\nIt would mean the world to me if your company or organization considered signing up for Baseplate\'s paid, private beta launch. We used the revenue the community gave us for [single-spa-workshop.com](https://single-spa-workshop.com) to create Baseplate, and plan to use Baseplate revenue to fund maintenance of single-spa\'s open source ecosystem. The Baseplate team is proudly a worker-owned business that has not sacrificed ownership of the company to outside investors. We built Baseplate with the revenue the community gave us via single-spa-workshop.com as the initial funding, which is only a few thousand dollars a month. The best Christmas present I could receive this year is a few dozen companies signing up immediately and putting Baseplate on their Q1 or Q2 roadmaps for 2024. I am asking for corporate partners to ensure long term financial sustainability so that single-spa will remain a good microfrontends solution for years to come.\\n\\n[Contact Baseplate Sales](mailto:sales@baseplate.cloud)\\n\\n## Summary\\n\\nsingle-spa@6 provides advanced features such as async navigation cancelation and parcel-only mode (via `patchHistoryApi`), while also updating the package configuration to use modern NodeJS and bundler features like [package entrypoints](https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#packages_package_entry_points) and [`\\"type\\": \\"module\\"`](https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#packages_type). We also updated `urlRerouteOnly` to default to `true`, as it boosts performance and we consider it to be a best practice to author applications that work when urlRerouteOnly is set to true.\\n\\n## Browser Support / IE11\\n\\n**We still support IE11** and the same versions of NodeJS (at least as old as Node 10). However, we\'ve changed our defaults such that IE11 is only supported with some additional configuration, as described in the IE11 Migration section below.\\n\\nFor the `single-spa` npm package, we plan single-spa@6 to be the last major version that supports IE11. In general, we\'ve released a major version of single-spa every 1-2 years. We do not have a concrete timeline or plans for single-spa@7, and will accept community contributions for any important patches to single-spa@6 after single-spa@7 is released.\\n\\nFor all surrounding packages (single-spa-react, single-spa-vue, systemjs-webpack-interop, single-spa-angular, etc) we may begin dropping IE11 support sooner than the single-spa@7 release. As we do so, we\'ll create documentation that lists the latest versions of packages that support IE11, and also accept community contributions to those versions for important updates.\\n\\nThe motivation for dropping IE11 support over time is to allow our core team to spend less time on supporting a nine year old browser and more time pushing the single-spa ecosystem forward. Also, we believe that the majority of end users should not suffer performance penalties because of a small percentage of users still using IE11. Slowly dropping IE11 also will also allow us to focus on a systemjs-less future for single-spa, where native browser modules are used rather than systemjs modules.\\n\\nWe understand and sympathize with companies who cannot drop IE11 support now, which is why we\'re supporting IE11 even though much of the ecosystem has already dropped it (Vue 3 does not support ie11, Angular only does after some effort, and even webpack 5 requires extra configuration to get it working in IE11). Many of single-spa\'s users are large financial institutions, large ecommerce companies, and other very large companies, where dropping IE11 support is a long process that involves many dozens of people from separate departments. We encourage single-spa users to start the conversations at your companies about dropping IE11 support, even if they take a long time or result in a decision to drop IE11 years in the future.\\n\\n## Migration\\n\\nWe think that >95% of single-spa users will be able to safely upgrade with no code changes. The breaking changes below are largely related to advanced features that most single-spa users do not use.\\n\\n### Steps\\n\\n1. If using SystemJS + import maps, change the URL of single-spa in your import map:\\n\\n```diff\\n<script type=\\"systemjs-importmap\\">\\n  {\\n    \\"imports\\": {\\n-     \\"single-spa\\": \\"https://cdn.jsdelivr.net/npm/single-spa@5.9.2/lib/system/single-spa.min.js\\"\\n+     \\"single-spa\\": \\"https://cdn.jsdelivr.net/npm/single-spa@6.0.0/lib/es2015/system/single-spa.min.js\\"\\n    }\\n  }\\n<\/script>\\n```\\n\\n2. In all your microfrontends (including root config), upgrade single-spa:\\n\\n```sh\\nnpm install single-spa@6\\nyarn add single-spa@6\\npnpm install single-spa@6\\n```\\n\\n3. Test things out.\\n4. If your app is not re-rendering during route transitions like it should (this is most common for Angular apps, but can happen in other frameworks to if you do a route transition without modifying the URL), change your root config\'s call to `start()`\\n\\n```diff\\nimport { start } from \'single-spa\';\\n\\n// DO NOT MAKE THIS CHANGE unless you are experiencing problems.\\n- start();\\n+ start({\\n+   urlRerouteOnly: false\\n+ });\\n```\\n\\nThat\'s it! If you experience other issues, let us know in Github issues.\\n\\n### IE11\\n\\nIf you support IE11, use the `es5` version of single-spa rather than `es2015`. The method of doing this depends on your configuration - some common ones are explained below:\\n\\n#### Import Maps\\n\\n```diff\\n<script type=\\"systemjs-importmap\\">\\n  {\\n    \\"imports\\": {\\n-     \\"single-spa\\": \\"https://cdn.jsdelivr.net/npm/single-spa@6.0.0/lib/es2015/system/single-spa.min.js\\"\\n+     \\"single-spa\\": \\"https://cdn.jsdelivr.net/npm/single-spa@6.0.0/lib/es5/system/single-spa.min.js\\"\\n    }\\n  }\\n<\/script>\\n```\\n\\n#### Webpack\\n\\nIf externalizing single-spa in your webpack config (very common, and the default with webpack-config-single-spa), you do not need to make the changes below. Otherwise, though, these changes will ensure you use the IE11-compatible version of single-spa.\\n\\n```js\\n// webpack.config.js\\nmodule.exports = {\\n  resolve: {\\n    alias: {\\n      \\"single-spa\\": require.resolve(\\"single-spa/lib/es5/esm/single-spa.min.js\\"),\\n    },\\n  },\\n};\\n```\\n\\n#### Rollup\\n\\nUse https://www.npmjs.com/package/@rollup/plugin-alias to alias the import similarly to webpack\\n\\n#### Import\\n\\nIf you do not wish to change bundler configuration, you can modify your import statements.\\n\\n```diff\\n- import { start } from \'single-spa\';\\n+ import { start } from \'single-spa/lib/es5/esm/single-spa.min.js\';\\n```\\n\\n## Breaking Changes\\n\\n- single-spa\'s package.json\'s `\\"main\\"` field now points to an es2015 version of single-spa that does not work in IE11. To support IE11, see section below.\\n- Delay patching history api until start() or patchHistoryApi() is called. [Github link](https://github.com/single-spa/single-spa/pull/827)\\n- Do not show start() warning when registerApplication hasn\'t been called (for parcel-only use cases) [Github link](https://github.com/single-spa/single-spa/pull/827)\\n- Change urlRerouteOnly default value to true. This is a performance boost for most applications, but for some situations can result in single-spa not triggering mounts/unmounts when it should. You can read more about it at https://single-spa.js.org/docs/api#start and https://github.com/single-spa/single-spa/issues/484. Angular users may want to set it to false due to nuanced behavior of angular router. To do so, call `start({urlRerouteOnly: false})` in your root config. [Github link](https://github.com/single-spa/single-spa/pull/828)\\n- `cancelNavigation(val)` no longer cancels navigation if `val` is falsy [Github link](https://github.com/single-spa/single-spa/pull/826)\\n- single-spa\'s package.json `\\"type\\"` is now set to `\\"module\\"`. This only impacts NodeJS usage of single-spa (not webpack/rollup/browser). Read more at [official nodejs docs](https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#packages_type).\\n- single-spa\'s package.json now has `\\"exports\\"`. This changes which of single-spa\'s bundles are used by NodeJS, webpack, and rollup. The main change is that webpack / rollup will now use an IE11-incompatible (es2015) version of single-spa. See IE11 section below for more details. Additionally, an ESM version of single-spa will now be used when loaded via `import(\'single-spa\')` or `import \'single-spa\';`, whereas a UMD version will be used when calling `require(\\"single-spa\')`. To avoid the [dual package hazard](https://nodejs.org/dist/latest-v16.x/docs/api/packages.html#packages_dual_commonjs_es_module_packages), only use `import` or `require` to load single-spa in your NodeJS code - do not use both. You can see the package exports at https://github.com/single-spa/single-spa/blob/dea22f1aac39777a07252897ae625ab1d8313e9d/package.json#L8-L25.\\n- The published `umd` builds now have `.cjs` extensions rather than `.js`, since all `.js` files in the single-spa package are assumed to be ESM.\\n\\n```sh\\nFile structure published to npm\\n\\n# Before\\n# See https://www.jsdelivr.com/package/npm/single-spa?path=lib&version=5.9.3\\nlib/\\n  # IE11\\n  umd/\\n    single-spa.dev.js\\n    single-spa.min.js\\n  # IE11\\n  esm/\\n    single-spa.dev.js\\n    single-spa.min.js\\n  # IE11\\n  system/\\n    single-spa.dev.js\\n    single-spa.min.js\\n  # No IE11\\n  es2015/\\n    single-spa.dev.js\\n    single-spa.min.js\\n\\n# After\\n# See https://www.jsdelivr.com/package/npm/single-spa?path=lib&version=6.0.0\\nlib\\n  # IE11\\n  es5/\\n    umd/\\n      single-spa.dev.js\\n      single-spa.min.js\\n    system/\\n      single-spa.dev.js\\n      single-spa.min.js\\n    esm/\\n      single-spa.dev.js\\n      single-spa.min.js\\n  # No IE11\\n  es2015/\\n    umd/\\n      single-spa.dev.cjs\\n      single-spa.min.cjs\\n    system/\\n      single-spa.dev.js\\n      single-spa.min.js\\n    esm/\\n      single-spa.dev.js\\n      single-spa.min.js\\n```\\n\\n## Features\\n\\n## Async navigation cancelation\\n\\nWe\'ve added support for async navigation cancelation. To use it, call `cancelNavigation(promise)` with a promise as an argument. Single-spa will wait until that promise resolves/rejects before proceeding with navigation. If the promise resolves with a truthy value, navigation is canceled. If the promise resolves with a falsy value or rejects, navigation is not canceled. [Github link](https://github.com/single-spa/single-spa/pull/826)\\n\\n```js\\nwindow.addEventListener(\\"single-spa:before-routing-event\\", (evt) => {\\n  if (evt.detail.oldUrl === \\"/settings\\") {\\n    evt.detail.cancelNavigation(checkSettingsOkay());\\n  }\\n});\\n\\nasync function checkSettingsOkay() {\\n  const response = await fetch(\\"/api/settings-okay\\");\\n  if (response.ok) {\\n    return true;\\n  } else {\\n    alert(\\"Please fix your settings before leaving the page\\");\\n    return false;\\n  }\\n}\\n```\\n\\n### New patchHistoryApi\\n\\nWe\'ve exposed a new `patchHistoryApi()` api. This lets you use single-spa\'s modified implementations of pushState/replaceState/popstate/hashchange without using single-spa applications. This is intended to be used by single-spa users who exclusively use single-spa parcels, rather than applications [Github link](https://github.com/single-spa/single-spa/pull/827)\\n\\n```js\\nimport { patchHistoryApi, mountRootParcel } from \\"single-spa\\";\\n\\npatchHistoryApi({\\n  urlRerouteOnly: true,\\n});\\n\\n// now you don\'t need to call start() if you\'re only using parcels\\n\\nmountRootParcel(parcelConfig, parcelProps);\\n```\\n\\n### New profiler\\n\\nWe\'ve implemented a profiler that is available within the dev builds of single-spa@6. A visualization of the profiler is available in the single-spa-inspector@0.6.0 browser extension:\\n\\n- Implement profiler for lifecycle events. by @joeldenning in [#868](https://github.com/single-spa/single-spa/pull/868)\\n- Implement parcel and routing profiler events. by @joeldenning in [#903](https://github.com/single-spa/single-spa/pull/903)\\n\\n<img src=\\"/img/profiler-screenshot.png\\" alt=\\"Screenshot of single-spa-inspector profiler tab\\" />\\n\\n## Fixes\\n\\n- Fix regression with parcel name [Github link](https://github.com/single-spa/single-spa/pull/825)\\n- Ensure all reroute promises (triggerAppChange() return value) resolve even during cancelation [Github link](https://github.com/single-spa/single-spa/pull/831)\\n- fix(types): fix SingleSpaAppsByNewStatus interface by @FelixGraf in [#988](https://github.com/single-spa/single-spa/pull/988)\\n- Ensure app is unmounted during unregisterApplication. Resolves #871 by @joeldenning in [#875](https://github.com/single-spa/single-spa/pull/875)\\n\\n## Maintenance\\n\\n- Switch from yarn -> pnpm [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Upgrade all dependencies [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Upgrade husky from v4 to v7. Use pinst to avoid issues with yarn 2 users as described in https://typicode.github.io/husky/#/?id=yarn-2 [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Upgrade to Jest 27. Fix tests to work with Jest 27. [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Upgrade to Node 16. Fix tests to work with Node 16 (Fix tests in Node 15 #652) [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Run upgraded version of prettier on all files. [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Remove unused babel-eslint dependency [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Upgrade to new package names for all rollup plugins. (@rollup/plugin-node-resolve instead of rollup-plugin-node-resolve) [Github link](https://github.com/single-spa/single-spa/pull/824)\\n- Remove file size impact workflow since it\'s broken. by @joeldenning in [#879](https://github.com/single-spa/single-spa/pull/879)\\n- Remove console.log in test by @joeldenning in [#878](https://github.com/single-spa/single-spa/pull/878)"},{"id":"/2023/11/07/core-team-meeting-notes","metadata":{"permalink":"/blog/2023/11/07/core-team-meeting-notes","source":"@site/blog/2023-11-07-core-team-meeting-notes.md","title":"November 2023 Core Team Meeting","description":"Attendees: Joel Denning, Milan Kovacic, Jake Hayes","date":"2023-11-07T00:00:00.000Z","formattedDate":"November 7, 2023","tags":[],"readingTime":0.705,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"single-spa 6","permalink":"/blog/2023/11/27/single-spa-6"},"nextItem":{"title":"Introducing Single-Spa\'s New Core Team Members","permalink":"/blog/2023/10/11/introducing-single-spa-new-core-team-members"}},"content":"Attendees: Joel Denning, Milan Kovacic, Jake Hayes\\n\\n## November 2023 Roadmap\\n\\n1. Release `single-spa@6` as latest\\n2. Consolidate and update the example projects\\n\\n## Meeting Notes\\n\\n- Open pull requests, pressing Github issues\\n  - We reviewed https://github.com/single-spa/single-spa-react/pull/197\\n- Core team vacancy\\n  - Add Jake Hayes to the #core-team channel, but not officially a core team member\\n  - Joel will reach out to Ian about joining the core team.\\n- Single-spa roadmap\\n- Maintenance update/plan\\n\\n## Roadmap Brainstorm\\n\\n- Adding unit tests to existing projects\\n- SystemJS -> ESM migration\\n- create-single-spa update (https://github.com/cruft/cruft)\\n- Release single-spa 6 as latest\\n- Improve shared dependencies management\\n- Autopublishes to npm\\n- Server rendering enhancements?\\n- Support for NextJS, NuxtJS, Remix, create-react-app, and other build tools\\n- Consolidate example projects\\n- Feature voting\\n- Automated integration tests for popular frameworks\\n- Update create-single-spa dependencies"},{"id":"/2023/10/11/introducing-single-spa-new-core-team-members","metadata":{"permalink":"/blog/2023/10/11/introducing-single-spa-new-core-team-members","source":"@site/blog/2023-10-11-introducing-single-spa-new-core-team-members.md","title":"Introducing Single-Spa\'s New Core Team Members","description":"Please welcome the latest additions to the Single-Spa core team. These talented individuals bring fresh energy and a wealth of expertise and are poised to revitalize and expand the Single-Spa project.","date":"2023-10-11T00:00:00.000Z","formattedDate":"October 11, 2023","tags":[],"readingTime":1.9,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"November 2023 Core Team Meeting","permalink":"/blog/2023/11/07/core-team-meeting-notes"},"nextItem":{"title":"The single-spa core team is expanding","permalink":"/blog/2023/08/22/single-spa-core-is-expanding"}},"content":"Please welcome the latest additions to the Single-Spa core team. These talented individuals bring fresh energy and a wealth of expertise and are poised to revitalize and expand the Single-Spa project.\\n\\n## Meet the Team\\n\\n**[Artur Androsovych](https://github.com/arturovt)**\\n\\nArtur Androsovych is a Google Developer Expert in Angular and an open-source contributor who has been focusing on runtime performance and teaching teams about Angular internals for the past few years. He has maintained the single-spa-angular project for years, and we\'re excited for him to join the core team.\\n\\n**[Roberto Mosca](https://github.com/robmosca)**\\n\\nRoberto is a Principal Software Engineer at TravelPerk (www.travelperk.com), where he is the go-to person for all things related to their frontend platform. With a full-stack background, he\'s got his hands on a variety of tech \u2014 from Python to NodeJS, React, Webpack... Before diving into the world of business travel, he was immersed in biomedical research as a bioinformatician. When he is not in front of a screen, you\u2019ll find him swimming, cooking up some Italian delicacies, or tinkering with his Rubik\u2019s cube-solving robots.\\n\\n**[Milan Kovacic](https://github.com/MilanKovacic)**\\n\\nMilan Kovacic is a seasoned software consultant with deep expertise in various development domains. On the frontend side, his work is marked by proficiency in React, TypeScript, and the integration of microfrontends. For backend solutions, he mostly relies on the .NET framework, C#\u2014often utilizing microservices architecture. Additionally, Milan is experienced with cloud technologies, regularly working with platforms like AWS and Azure. Beyond traditional development, he places great emphasis on ensuring a smooth developer experience and promotes the use of automation and efficient DevOps practices to streamline development workflows.\\n\\nThese three new members will be joining current members Joel Denning, Carlos Filoteo, and Anthony Frehner to manage GitHub and Slack issues and actively develop new features. We\u2019d also like to give special recognition to contributors from Qiankun for their extensive support over the years.\\n\\nAs part of this team update, we\u2019ll also be creating a public roadmap, providing transparency about Single-Spa\'s future direction. To maintain transparency and encourage collaboration, we\'re establishing monthly meetings where the core team will discuss progress, challenges, and ideas. Meeting notes will be publicly available, ensuring that the community is well-informed and able to participate in our discussions.\\n\\nSo stay tuned and join us on this journey shaping the future of microfrontends."},{"id":"/2023/08/22/single-spa-core-is-expanding","metadata":{"permalink":"/blog/2023/08/22/single-spa-core-is-expanding","source":"@site/blog/2023-08-22-single-spa-core-is-expanding.md","title":"The single-spa core team is expanding","description":"We are happy to announce that the single-spa core team is opening applications for two new members! As a core team member, you will help us maintain and guide the growing single-spa ecosystem by responding to Github and Slack issues, implementing new features, and helping to create the roadmap for the future of single-spa.","date":"2023-08-22T00:00:00.000Z","formattedDate":"August 22, 2023","tags":[],"readingTime":1.345,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Introducing Single-Spa\'s New Core Team Members","permalink":"/blog/2023/10/11/introducing-single-spa-new-core-team-members"},"nextItem":{"title":"single-spa 5","permalink":"/blog/2020/02/24/single-spa-5"}},"content":"We are happy to announce that the single-spa core team is opening applications for two new members! As a core team member, you will help us maintain and guide the growing single-spa ecosystem by responding to Github and Slack issues, implementing new features, and helping to create the roadmap for the future of single-spa.\\n\\nOur current core team consists of Joel Denning, Carlos Filoteo, and Anthony Frehner. We also thank Justin McMurdie and Bret Little for their valuable contributions during their time with the single-spa core team.\\n\\nSingle-spa owes its success to the people and companies who support it. If you want to contribute but aren\u2019t able to join the core team, consider applying to be a maintainer. Maintainers are volunteers who receive Github write access to specific subprojects within the ecosystem. If you\u2019re a manager at a company that uses single-spa, we encourage you to allow your developers to volunteer their time as maintainers or core team members so that the project can continue to grow and develop.\\n\\nThe single-spa core team and maintenance are unpaid volunteer positions. Looking ahead, if any core team members or maintainers are interested in new paid roles, Convex Cooperative (the company Joel works for) will be considering hiring new developers from the single-spa team. It\u2019s important to state that Convex will not poach developers away from companies who allow their developers to help us maintain single-spa\u2014our priority is nurturing the growth and development of the single-spa ecosystem.\\n\\nIf interested in applying to be a single-spa maintainer or core team member, please fill out the following Google Form before September 1, 2023:\\n\\n[https://docs.google.com/forms/d/1zIfP2kYjNBCi-qjKf9T1-sNT1VLSXTB9twwX_mxKYxU/edit](https://docs.google.com/forms/d/1zIfP2kYjNBCi-qjKf9T1-sNT1VLSXTB9twwX_mxKYxU/edit)"},{"id":"/2020/02/24/single-spa-5","metadata":{"permalink":"/blog/2020/02/24/single-spa-5","source":"@site/blog/2020-02-24-single-spa-5.md","title":"single-spa 5","description":"Today we released single-spa@5.0.0.","date":"2020-02-24T00:00:00.000Z","formattedDate":"February 24, 2020","tags":[],"readingTime":4.29,"hasTruncateMarker":false,"authors":[{"name":"Joel Denning","url":"https://twitter.com/joelbdenning","imageURL":"https://avatars2.githubusercontent.com/u/5524384?s=460&v=4"}],"frontMatter":{"title":"single-spa 5","author":"Joel Denning","authorURL":"https://twitter.com/joelbdenning","authorImageURL":"https://avatars2.githubusercontent.com/u/5524384?s=460&v=4"},"unlisted":false,"prevItem":{"title":"The single-spa core team is expanding","permalink":"/blog/2023/08/22/single-spa-core-is-expanding"},"nextItem":{"title":"single-spa Inspector and 4.1","permalink":"/blog/2019/02/20/single-spa-inspector"}},"content":"Today we released single-spa@5.0.0.\\n\\nHere are the highlights:\\n\\n- Performance focus: 35% decrease in library size.\\n- A CLI for single-spa: [create-single-spa](/docs/create-single-spa)\\n- New tutorial videos: [Youtube playlist](https://www.youtube.com/playlist?list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU) / [Bilibili space](https://space.bilibili.com/495254378/video)\\n- New framework-specific example repositories - [React example](https://github.com/react-microfrontends), [Vue example](https://github.com/vue-microfrontends), [Multiple frameworks example](https://github.com/polyglot-microfrontends), [Full list](/docs/examples)\\n- Massively improved documentation, including [Concept: Microfrontends](/docs/microfrontends-concept) and [The Recommended Setup](/docs/recommended-setup).\\n\\n[Release notes here](https://github.com/single-spa/single-spa/releases/tag/v5.0.0)\\n\\n## Migration from 4 to 5\\n\\nFor every user we\'re aware of, **you do not need to change anything in your code in order to upgrade to single-spa@5**. The breaking changes listed in the release notes are the removal of features that were originally used by Canopy Tax, but were never documented.\\n\\nIf installing from npm, you can simply `npm install --save single-spa@5.0.0` or `yarn add single-spa@5.0.0`.\\n\\nAlternatively, single-spa is available on [cdnjs](https://cdnjs.com/libraries/single-spa), [jsdelivr](https://www.jsdelivr.com/package/npm/single-spa), and [unpkg](https://unpkg.com/browse/single-spa/).\\n\\nThe single-spa core team is committed to treating our users well, which includes not introducing massive breaking changes. The core single-spa API has not seen massive breaking changes [since single-spa@3 in August 2016](https://github.com/single-spa/single-spa/releases/tag/v3.0.0). We have added features and improved things, but single-spa is a stable technology. We are committed to maintaining it, documenting it, and adjusting it as technologies like in-browser modules become more and more popular and viable.\\n\\n## Performance improvements\\n\\nThe ESM version of single-spa@4 was 23.8kb (7.2kb gzipped). That was improved in single-spa@5 to 15.5kb (5.1kb gzipped). We did this by optimizing our build process and removing unused features.\\n\\n## single-spa CLI\\n\\nSince single-spa\'s inception, bundler configuration has been a huge source of user pain. We have heard this pain and implemented [create-single-spa](/docs/create-single-spa), which creates (and sometimes can update) repositories that are ready to be used as single-spa microfrontends. For Angular and Vue, the official CLIs are used with a few extra plugins automatically installed. For React, a default webpack config with decent eslint / prettier defaults is set up.\\n\\nAdditionally, we have added a lot of documentation for webpack in [The Recommended Setup](/docs/recommended-setup#build-tools-webpack--rollup).\\n\\n## Tutorial videos\\n\\nWe understand that single-spa is more than just a library - it is an architecture. The single-spa library itself is the core, but the surrounding ecosystem of concepts and libraries are equally important to successfully migrating to single-spa and having it work for you. As such, we have created a Youtube playlist, currently consisting of seven videos, to help you get started.\\n\\n[Youtube playlist](https://www.youtube.com/playlist?list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU) / [Bilibili space](https://space.bilibili.com/495254378/video)\\n\\nThe videos currently cover the following topics:\\n\\n- What are Microfrontends?\\n- In-browser vs build-time JavaScript modules\\n- Import Maps\\n- Local Development with single-spa and import maps\\n- Deploying Microfrontends / Continuous Integration (CI)\\n- SystemJS intro\\n- Lazy Loading\\n- Bundlers, webpack, and rollup.\\n\\n## New example repositories\\n\\nWhat started out as Canopy Tax\'s special sauce for independently deployed frontend microservices is now fully accessible to the public with our [new set of example repos](/docs/examples). We have a React example, a Vue example, and a polyglot (multiple framework) example. We hope to add an Angular example, after we achieve support for Angular 9. These example repositories are actively watched and maintained by the single-spa core team, and reflect our current opinions on the best, production-viable way to do microfrontends.\\n\\nFurthermore, we have deployed each of the examples to our new domains:\\n\\n- https://react.microfrontends.app\\n- https://polyglot.microfrontends.app\\n- https://vue.microfrontends.app\\n\\n## Documentation overhaul\\n\\nWe removed several dated documentation pages, and added several that were very much lacking. Here are a few pages that give you the most bang for your buck:\\n\\n- [Concept: Microfrontend](/docs/microfrontends-concept)\\n- [The Recommended Setup](/docs/recommended-setup)\\n- [create-single-spa CLI](/docs/create-single-spa)\\n\\n## Development builds and error codes\\n\\nTaking inspiration from the [react development and production builds](https://reactjs.org/docs/optimizing-performance.html#use-the-production-build), we now publish to NPM both development and production builds in the following formats: UMD, ESM, and System.register.\\n\\nYou can see the [published build files here](https://unpkg.com/browse/single-spa@5.0.0/lib/). The `.dev.js` files provide full debugging information in the browser console, whereas the `.min.js` files give you a numeric error code and a link to a documentation page that explains the error. We hope that these error codes and documentation for them will improve discoverability of relevant documentation when you\'re setting up single-spa.\\n\\nAn example of these new documentation pages for error codes is [found here](/error/?code=35&arg=application&arg=app1&arg={}).\\n\\n## Governance\\n\\nSome of you may have noticed that we recently moved all github repos from https://github.com/CanopyTax to https://github.com/single-spa. Canopy Tax was the company where single-spa was first authored, but as a core team we asked to move ownership and governance of the projects to an organization fully managed by the open source community. In agreement with Canopy, we made that change.\\n\\nThis change does not mean anything drastic for single-spa. Its license was and is MIT, and we have no plans to do anything with the project besides make it better.\\n\\n## Where next?\\n\\nWe are actively [translating the single-spa documentation to Chinese](https://github.com/single-spa/zh-hans.single-spa.js.org), and hope to add other languages soon. We will add full [Angular 9 support](https://github.com/single-spa/single-spa-angular/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+angular+9) soon, and hope to add [server rendering](https://github.com/single-spa/single-spa/issues/103) in an upcoming release.\\n\\nPlease [contribute to our code](/docs/contributing-overview) and [ecosystem](/docs/ecosystem), [join our single-spa slack channel](https://join.slack.com/t/single-spa/shared_invite/zt-2efw13fg4-oJgemeyCUJv4~JrQlYttnA), [follow our official Twitter account](https://twitter.com/Single_spa), and contribute to [our open collective](https://opencollective.com/single-spa). The [single-spa core team](/contributors) all have full-time jobs and maintain this project on a volunteer basis."},{"id":"/2019/02/20/single-spa-inspector","metadata":{"permalink":"/blog/2019/02/20/single-spa-inspector","source":"@site/blog/2019-02-20-single-spa-inspector.md","title":"single-spa Inspector and 4.1","description":"Background","date":"2019-02-20T00:00:00.000Z","formattedDate":"February 20, 2019","tags":[],"readingTime":1.775,"hasTruncateMarker":false,"authors":[{"name":"Anthony Frehner","url":"https://twitter.com/aahfrena","imageURL":"https://pbs.twimg.com/profile_images/1037162092963348480/1XLEV4MK_400x400.jpg"}],"frontMatter":{"title":"single-spa Inspector and 4.1","author":"Anthony Frehner","authorURL":"https://twitter.com/aahfrena","authorImageURL":"https://pbs.twimg.com/profile_images/1037162092963348480/1XLEV4MK_400x400.jpg"},"unlisted":false,"prevItem":{"title":"single-spa 5","permalink":"/blog/2020/02/24/single-spa-5"},"nextItem":{"title":"single-spa parcels, explained","permalink":"/blog/2018/06/19/single-spa-parcels-explained"}},"content":"## Background\\n\\nFor a long time, Canopy has had the benefit of using a tool called [sofe inspector](https://github.com/single-spa/sofe-inspector) (note: this is an out-of-date version of it) to list, override, and interact with single-spa applications. There has always been a desire to [figure out how to share this tool so others can benefit as well](https://github.com/single-spa/single-spa/issues/151).\\n\\nWith that in mind, I\'m proud to announce an initial release for **[single-spa Inspector](https://github.com/single-spa/single-spa-inspector)**! single-spa Inspector is a Firefox and Chrome extension, much like React/Vue devtools, that allows you see and interact with your single-spa applications and configuration.\\n\\n## Current Inspector Features\\n\\n- List registered applications\\n- Show application status\\n- Force an app to mount or unmount\\n- Hover over an app name to have an \\"inspect element\\"-like view of your apps (Overlays)\\n\\n(Note: Overlays require a small update to your code, but should hopefully be simple! See [how to configure app overlays](https://github.com/single-spa/single-spa-inspector#configuring-app-overlays))\\n\\n**The single-spa Inspector will only work with single-spa versions 4.1 and higher**, since we had to expose and add some functionality to the single-spa library itself in order to implement these features.\\n\\n## single-spa 4.1\\n\\nsingle-spa 4.1 was released, which includes a couple of key updates:\\n\\n1. Support for single-spa Inspector\\n1. ESM bundle output\\n1. Simpmlified test configuration for developers/contributors to single-spa\\n\\nFor most people, ESM (EcmaScript Module) support shouldn\'t affect how you use single-spa, but for those looking to play around with modules or other advanced Javascript things, it\'s a welcome addition.\\n\\nWe also changed our test suite to purely use Jest instead of Saucelabs, and hopefully false positive \\"failing\\" tests on pull requests will be a thing of the past.\\n\\n## Help Wanted!\\n\\nIf you would like to suggest a new feature for single-spa Inspector, report a bug, improve our (admittedly horrible and hopefully temporary) UI/UX, or add features, please see the [github repo](https://github.com/single-spa/single-spa-inspector) and hack away!\\n\\nWe also hope to update some of our example repos to the lastest single-spa so that anyone with the extension installed can test out the features and see how to implement overlays. But this process will go faster if someone wants to help out. :)\\n\\nThank you!"},{"id":"/2018/06/19/single-spa-parcels-explained","metadata":{"permalink":"/blog/2018/06/19/single-spa-parcels-explained","source":"@site/blog/2018-06-19-single-spa-parcels-explained.md","title":"single-spa parcels, explained","description":"Ever since single-spa@1.0.0, the single-spa team has been dedicated to bringing microservices to the frontend. We have made it possible for AngularJS, React, Angular, Vue, and other frameworks to coexist side by side in the same page.","date":"2018-06-19T00:00:00.000Z","formattedDate":"June 19, 2018","tags":[],"readingTime":3.69,"hasTruncateMarker":false,"authors":[{"name":"Joel Denning","url":"https://twitter.com/joelbdenning","imageURL":"https://avatars2.githubusercontent.com/u/5524384?s=400&u=ff145fcb2ae5305555628a446e9f725d4e145aaa&v=4"}],"frontMatter":{"title":"single-spa parcels, explained","author":"Joel Denning","authorURL":"https://twitter.com/joelbdenning","authorImageURL":"https://avatars2.githubusercontent.com/u/5524384?s=400&u=ff145fcb2ae5305555628a446e9f725d4e145aaa&v=4"},"unlisted":false,"prevItem":{"title":"single-spa Inspector and 4.1","permalink":"/blog/2019/02/20/single-spa-inspector"},"nextItem":{"title":"A step-by-step guide to single-spa","permalink":"/blog/2016/12/16/a-step-by-step-guide-to-single-spa"}},"content":"Ever since single-spa@1.0.0, the single-spa team has been dedicated to bringing microservices to the frontend. We have made it possible for AngularJS, React, Angular, Vue, and other frameworks to coexist side by side in the same page.\\n\\nAnd with the release of [version 4](https://github.com/single-spa/single-spa/releases/tag/v4.0.0), I\u2019m pleased to announce that [single-spa](https://github.com/single-spa/single-spa) is expanding that effort so that **_individual components_** written with different frameworks can interoperate. It is new terrain for the single-spa community, which previously had focused on getting large applications to interoperate with each other, instead of the individual components.\\n\\n## Another way to do framework agnostic components?\\n\\nFor those familiar with [web components](https://developer.mozilla.org/en-US/docs/Web/Web_Components) and [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements), you may be wondering why a JavaScript library would try to do what browsers are starting natively to do.\\n\\nAnd as one of the contributors to the custom elements polyfill, let me be the first one to say that we did not make this decision lightly.\\n\\nIf you\u2019re interested in diving into the details, check out [One Company\u2019s Relationship With Custom Elements](https://medium.com/canopy-tax/one-companys-relationship-with-custom-elements-d360baf3b253), which explains some of the difficulties we\u2019ve been through with web components and custom elements.\\n\\nTLDR: React and some other frameworks don\u2019t interop with custom elements very well. Additionally dealing with inner HTML, attributes vs properties, and customized builtins can be a pain.\\n\\n## Okay but you haven\u2019t told me what a single-spa parcel is\\n\\nA parcel is single-spa\u2019s way of building a component in one framework and using it in another.\\n\\nTo implement a parcel, just create a JavaScript object that has 3\u20134 functions on it. We call this JavaScript object a _parcel config_ and there are three required functions to implement: bootstrap, mount, and unmount. A fourth function, update, is optional.\\n\\nEach of the functions will be called by single-spa at the right time, but the parcel config will control what happens. In other words, single-spa controls the \u201cwhen,\u201d but the parcel config controls the \u201cwhat\u201d and the \u201chow.\u201d\\n\\nOnce you\u2019ve implemented the parcel config, simply call singleSpa.mountRootParcel(parcelConfig, parcelProps) to mount it. This is the key to what makes parcels framework agnostic \u2014 regardless of whether the parcel config is implemented with React, Angular, Vue, or anything else, to use the parcel you always just call mountRootParcel().\\n\\n## A few more specifics\\n\\nWe\u2019ve glossed over a few things that I want to touch on real quick:\\n\\n- **How do you implement the lifecycle functions on the parcel config?**\\n\\n      \\t\\tUse a helper library for your framework of choice. [single-spa-react](https://github.com/single-spa/single-spa-react), [single-spa-angular](https://github.com/single-spa/single-spa-angular) (for angular@2+), [single-spa-angularjs](https://github.com/single-spa/single-spa-angularjs), [single-spa-vue](https://github.com/single-spa/single-spa-vue), and [others](https://github.com/single-spa/single-spa/blob/master/docs/single-spa-ecosystem.md) will implement the entire parcel config for you.\\n\\n- **What are the props you pass to mountRootParcel()?**\\n\\n      \\t\\tThe props passed as the second argument to singleSpa.mountRootParcel(parcelConfig, parcelProps) are an object with one required prop and as many custom props as you\u2019d like. The required prop is domElement, which tells the parcel where to mount. And the custom props get passed through to the parcel config lifecycle functions.\\n\\n- **How do you re-render and unmount a parcel?**\\n\\n      \\t\\tThe singleSpa.mountRootParcel() function returns a parcel object that lets you re-render and unmount the parcel whenever you\u2019d like to.\\n\\n      \\t\\t<iframe src=\\"https://medium.com/media/b2d981b380b937009f7ce84e1cc2d753\\" frameBorder=\\"0\\" />\\n\\n## Syntactic sugar makes this easier\\n\\nCalling all of those functions manually might get annoying. So let\u2019s make it easier. Here\u2019s an example of some syntactic sugar for React. Similar features will be added soon for Angular, Vue, and other frameworks.\\n\\n<iframe src=\\"https://medium.com/media/9b5904d3423359cb2eef410f9ee35648\\" frameBorder=\\"0\\" />\\n\\n## How hard is it to try this out?\\n\\nYou can get started with parcels immediately, without using the rest of single-spa. To do so, either npm install or script tag single-spa, then call mountRootParcel with your first parcel config.\\n\\nYou can also check out [this codepen example](https://codepen.io/joeldenning/pen/qKVoQg?editors=0010#0) to start out.\\n\\nAnd if you are already a user of [single-spa applications](https://github.com/single-spa/single-spa/blob/master/docs/applications.md), parcels mean that your applications can mount and unmount shared functionality whenever you want them to. Since parcels don\u2019t have [activity functions](https://github.com/single-spa/single-spa/blob/master/docs/configuration#activity-function), you don\u2019t have to set up routes for them.\\n\\n## Let us know what you think!\\n\\nWe\u2019d love to get your feedback on parcels. What do you think of this new way of framework interop? Is the implementation easy to understand? Are parcels useful for you or do they not quite fit into what you\u2019re trying to accomplish?How hard was it for you to try out?\\n\\nCheck out the [official docs](https://github.com/single-spa/single-spa/blob/master/docs/parcels.md) for more examples, explanations, and [api documentation](https://github.com/single-spa/single-spa/blob/master/docs/parcels-api.md).\\n\\nAnd let us know your thoughts in the [single-spa Slack channel](https://join.slack.com/t/single-spa/shared_invite/zt-2efw13fg4-oJgemeyCUJv4~JrQlYttnA), a [Github issue](https://github.com/single-spa/single-spa/issues), or [on Twitter](https://twitter.com/Single_spa)!"},{"id":"/2016/12/16/a-step-by-step-guide-to-single-spa","metadata":{"permalink":"/blog/2016/12/16/a-step-by-step-guide-to-single-spa","source":"@site/blog/2016-12-16-a-step-by-step-guide-to-single-spa.md","title":"A step-by-step guide to single-spa","description":"Running Angular 1, React, Angular 2, and Vue.js side by side sounds pretty cool. And it seems appealing to have multiple applications coexisting on the same page, each lazily loaded.","date":"2016-12-16T00:00:00.000Z","formattedDate":"December 16, 2016","tags":[],"readingTime":9.705,"hasTruncateMarker":false,"authors":[{"name":"Joel Denning","url":"https://twitter.com/Joelbdenning","imageURL":"https://pbs.twimg.com/profile_images/716746867451625472/2NMyKAd1_400x400.jpg"}],"frontMatter":{"title":"A step-by-step guide to single-spa","author":"Joel Denning","authorURL":"https://twitter.com/Joelbdenning","authorImageURL":"https://pbs.twimg.com/profile_images/716746867451625472/2NMyKAd1_400x400.jpg"},"unlisted":false,"prevItem":{"title":"single-spa parcels, explained","permalink":"/blog/2018/06/19/single-spa-parcels-explained"},"nextItem":{"title":"A Case for SOA in the Browser","permalink":"/blog/2016/02/26/a-case-for-soa-in-the-browser"}},"content":"Running Angular 1, React, Angular 2, and Vue.js side by side sounds pretty cool. And it seems appealing to have multiple applications coexisting on the same page, each lazily loaded.\\n\\nBut using [single-spa](/) for the first time can be tricky because you\u2019ll come across terms like \u201capplication lifecycles\u201d, \u201croot application\u201d, \u201cloading function\u201d, \u201cchild application\u201d, and \u201cactivity function.\u201d\\n\\nThis blog post will take you through setting things up and what choices you have when using single-spa. It\u2019s based on what I\u2019ve seen at [Canopy Tax](https://medium.com/canopy-tax) where we went from an Angular 1 monolith to an Angular 1, React, and Svelte polyglot.\\n\\nIf you\u2019d like to jump straight to a fully working, self contained code example, check out this [webpack single-spa starter project](https://github.com/joeldenning/simple-single-spa-webpack-example).\\n\\n## Step One: choose a module loader.\\n\\nYour module loader / bundler is the library you\u2019ll use to lazy load code. I recommend either [Webpack](https://webpack.js.org/) or [JSPM](https://jspm.io/), if you\u2019re starting from scratch.\\n\\nIf you go with Webpack, try to use Webpack 2 if you can, since it has [support for promise-based lazy loading](https://webpack.js.org/guides/migrating/#code-splitting-with-es2015). This will make things easier for you later on, since single-spa requires that your [loading functions](https://github.com/single-spa/single-spa/blob/master/docs/root-application.md#loading-function) return promises. If you can\u2019t use Webpack 2, getting single-spa to lazy load your code with Webpack 1 will require some boilerplate code.\\n\\nJSPM/SystemJS has worse documentation than Webpack, but is a great solution for module loading if you can get past that. I recommend using jspm@0.17\u200a\u2014\u200ait\u2019s still in beta but has been worked on for over a year and at Canopy we find it stable enough to use in production.\\n\\nIf you\u2019re struggling to decide between the two, then ask yourself the following: Do I want multiple completely separate bundles? If you don\u2019t, I recommend Webpack because it has better docs, a larger community, and fewer gotchas. Otherwise, I\u2019d go with JSPM, since Webpack has no plans to support dynamic runtime loading [(See tweet below from Mr. Larkin, himself)](https://twitter.com/TheLarkInn/status/789968589419745280).\\n\\n## Step Two: create a brand new HTML file\\n\\nThe next step is to create what single-spa calls your [\u201croot application.\u201d](https://github.com/single-spa/single-spa/blob/master/docs/root-application.md) Really your root application is just the stuff that initializes single-spa, and it starts with an HTML file.\\n\\nEven if you\u2019ve got an existing project that already has it\u2019s own HTML file, I recommend starting fresh with a new HTML file. That way, there is a clear distinction between what is in your root application (shared between all apps) and what is in a child application (not shared with everything).\\n\\nYou\u2019ll want to keep your root application as small as possible, since it\u2019s sort of the master controller of everything and could become a bottleneck. You don\u2019t want to be constantly changing both the root application and the child applications.\\n\\nSo for now, just have a `<script>` to a single JavaScript file (root-application.js), which will be explained in Step Three.\\n\\nSince Webpack is probably the more common use case, my code examples from here on will assume that you\u2019re using Webpack 2. The equivalent Webpack 1 or JSPM code has all the same concepts and only some minor code differences.\\n\\n```html\\n<!doctype html>\\n<html>\\n  <head>\\n    <meta charset=\\"utf-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width\\" />\\n    <title>A single-spa application</title>\\n  </head>\\n  <body>\\n    <div id=\\"cool-app\\"></div>\\n    <script src=\\"root-application.js\\"><\/script>\\n  </body>\\n</html>\\n```\\n\\n## Step Three: register an \u201capplication\u201d\\n\\nNow it\u2019s time to finish up your root application by writing your \u201croot-application.js\u201d file. The primary purpose of root-application.js is to call [singleSpa.registerApplication(..)](https://github.com/single-spa/single-spa/blob/master/docs/root-application.md#declaring-child-applications) for each of the applications that will be managed by single-spa.\\n\\nIf you\u2019re into analogies, you can think of single-spa as the operating system for your single page application, managing which \u201cprocesses\u201d (or \u201cchild applications\u201d) are running at any given time. At any moment, some of the child applications will be active on the DOM and others will not. As the user navigates throughout the app, some applications will be unmounting from the DOM and others will be mounting to the DOM.\\n\\nAnother way to look at it is that single-spa is a master router on top of your other routers.\\n\\nTo do this, first `npm install single-spa` and then call the [registerApplication](https://github.com/single-spa/single-spa/blob/master/docs/root-application.md#declaring-child-applications) function:\\n\\n```js\\nimport { registerApplication, start } from \\"single-spa\\";\\n\\n// Register your first application with single-spa. More apps will be registered as you create them\\nregisterApplication(\\"cool-app\\", loadCoolApp, isCoolAppActive);\\n\\n// Tell single-spa that you\'re ready for it to mount your application to the DOM\\nstart();\\n\\n// This is a \\"loading function\\"\\nfunction loadCoolApp() {\\n  return import(\\"./cool-app/cool.app.js\\");\\n}\\n\\n// This is an \\"activity function\\"\\nfunction isCoolAppActive() {\\n  return window.location.hash.startsWith(\\"#/cool\\");\\n}\\n```\\n\\nBecause single-spa is _so very_ cool, we\u2019ve created an app called \u201ccool-app\u201d that will be lazy loaded and mounted to the DOM whenever the url hash starts with `#/cool`.\\n\\nThe `loadCoolApp` function is what single-spa calls a loading function. Inside of it, the `import` introduces a code splitting point\u200a\u2014\u200aWebpack will create separate code chunks that will be lazy loaded by single-spa.\\n\\nFor your specific project, you probably won\u2019t have a hash prefix of \u201ccool\u201d, but I recommend establishing some kind of convention that makes it easy to determine which apps are active. This will simplify the maintenance of your activity functions, as you add more and more child applications.\\n\\nIf you\u2019re going to start out with just one child application, then it might make sense to implement the activity function as `() => true`. You can worry about getting fancier once you have more than one application.\\n\\nThe last thing is to call `start()`. This is something you **must do for things to work.** The purpose is to give control over timing and performance. But until that is a concern, `start` is just one of those things you do, and then maybe [read about it](https://github.com/single-spa/single-spa/blob/master/docs/single-spa-api.md#start) later if you ever need to.\\n\\n## Step Four: create \u201c.app.js\u201d file\\n\\nWhen you open up your index.html file in the browser, you\u2019ll now see\u2026.. a blank screen! We\u2019re really close, but there\u2019s one crucial step left: building your app.js file.\\n\\nAfter that, you\u2019ll have everything working for your first single-spa application.\\n\\nAn app.js file is a configuration file that you create for each child application. It is the code that is lazy loaded when your activity function returns true.\\n\\nThere are three things that you need to implement in the app.js file:\\n\\n<ol>\\n  <li><a href=\\"\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">A bootstrap lifecycle</a></li>\\n  <li><a href=\\"\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">A mount lifecycle</a></li>\\n  <li><a href=\\"\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">An unmount lifecycle</a></li>\\n</ol>\\n\\nA \u201clifecycle\u201d is a function or array of functions that will be called by single-spa; you export these from the app.js file. Each function must return a Promise so that single-spa knows when it is completed.\\n\\nHere is a simple example:\\n\\n```js\\n// single-spa will import this file and call the exported lifecyle functions\\n\\nlet user;\\n\\nexport function bootstrap() {\\n  return fetch(\\"/api/users/0\\")\\n    .then((response) => response.json())\\n    .then((json) => (user = json));\\n}\\n\\nexport function mount() {\\n  /* This is normally where you would have your framework-specific code like\\n   * ReactDOM.render or angular.bootstrap(). The fact that you can put *anything*\\n   * into this function is what makes single-spa so powerful -- any framework\\n   * can implement a \\"mount\\" and \\"unmount\\" to become a single-spa application.\\n   */\\n  return Promise.resolve().then(() => {\\n    document.getElementById(\\"user-app\\").innerHTML = `\\n        <div>\\n          Hello ${user.name}!\\n        <div>\\n      `;\\n  });\\n}\\n\\nexport function unmount() {\\n  /* Real world use cases would be something like ReactDOM.unmountComponentAtNode()\\n   * or vue.$destroy()\\n   */\\n  return Promise.resolve().then(() => {\\n    document.getElementById(\\"user-app\\").innerHTML = \\"\\";\\n  });\\n}\\n```\\n\\nAt this point, you might be seeing the `document.getElementById` and `innerHTML =` and worry that you\u2019ve been duped\u200a\u2014\u200amaybe single-spa is really just a poor excuse for a ui component framework.\\n\\nAnd really, don\u2019t we already have a lot of different ways to write UI components?\\n\\n### Getting all of those frameworks to work together.\\n\\n_Using multiple frameworks_ is where single-spa really shines. It is not a ui framework itself, but a framework for using other frameworks.\\n\\nEach child application can be written in any framework, so long as it implements application lifecycle functions. Then the mini-apps cooperate to form the entire single page application.\\n\\nSo going back to our previous example, we could choose to write our \u201ccool.app.js\u201d as an Angular 1 app, and choose something else for future apps:\\n\\n```js\\nimport singleSpaAngularJS from \\"single-spa-angularjs\\";\\nimport angular from \\"angular\\";\\nimport \\"./app.module.js\\";\\nimport \\"./routes.js\\";\\n\\nconst domElementGetter = () => document.getElementById(\\"cool-app\\");\\n\\nconst angularLifecycles = singleSpaAngularJS({\\n  angular,\\n  domElementGetter,\\n  mainAngularModule: \\"single-spa-app\\",\\n  uiRouter: true,\\n  preserveGlobal: true,\\n});\\n\\nexport const bootstrap = [\\n  aboutToBootstrap,\\n  angularLifecycles.bootstrap,\\n  doneBootstrapping,\\n];\\n\\nexport const mount = [angularLifecycles.mount];\\n\\nexport const unmount = [angularLifecycles.unmount];\\n\\nfunction aboutToBootstrap() {\\n  console.log(\\"about to bootstrapping\\");\\n  return Promise.resolve();\\n}\\n\\nfunction doneBootstrap() {\\n  console.log(\\"finished bootstrapping\\");\\n  return Promise.resolve();\\n}\\n```\\n\\nIn this example, we use a helper library called [single-spa-angularjs](https://github.com/single-spa/single-spa-angularjs) which abstracts away the specifics of initializing Angular 1 apps. This blogpost doesn\u2019t show you the `app.module.js` or `routes.js` files, but you can see an example implementation [here](https://github.com/single-spa/single-spa-examples/tree/master/src/angularJS).\\n\\nThe pattern is to call `singleSpaAngularJS` at the very beginning, which returns `bootstrap`, `mount`, and `unmount` lifecycle functions for you.\\n\\nYou might notice that this time the lifecycles are exported as arrays of functions instead of just functions\u200a\u2014\u200ayou can choose whichever works best for you.\\n\\nThe advantage of exporting an array of functions is that you can add in your own custom behavior (like `aboutToBootstrap` and `doneBootstrap`) that will run before or after the Angular 1 lifecycles. When you export an array, each item in the array must be a function that returns a promise. Single-spa will wait for each promise to resolve, in order, before calling the next function in the array.\\n\\nTo learn more about single-spa helper libraries, check out these github projects:\\n\\n<ul>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-angularjs\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-angularjs</a></li>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-angular\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-angular</a></li>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-react\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-react</a></li>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-vue\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-vue</a></li>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-svelte\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-svelte</a></li>\\n  <li><a href=\\"https://github.com/single-spa/single-spa-preact\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">single-spa-preact</a></li>\\n</ul>\\n\\nYou can also see a fully working example of an angular app coexisting with other apps at the [single-spa-examples](https://github.com/single-spa/single-spa-examples) repo or the [live demo](http://single-spa.surge.sh/).\\n\\n## Step Five: test it out!\\n\\nRefresh your page and you should now have a functioning single-spa application!\\n\\nTry navigating to a url that your child app is active for (`#/cool`) and then navigating away from it. When you do so, the page will not refresh but you should see your application mount itself to the DOM and then unmount.\\n\\nIf you run into problems, try to narrow down whether the problem is in the root application or in the child application. Is your root application being executed? Are the declareChildApplication calls being made? Have you called `start()`? Is there a network request to download the code for your child application? Is your child application\'s `bootstrap` lifecycle being called? What about `mount`?\\n\\n<img src=\\"https://cdn-images-1.medium.com/max/1600/1*WMFuo-hz-Q31UVbTHAx4lw.png\\" alt=\\"cdn-images-1\\" />\\n\\nIt may be helpful to add a navigation menu, so you can verify everything mounts and unmounts to the DOM correctly. If you want to level up your single-spa skills even more, make the navigation menu an entire child application whose activity function is `() => true`. An example that does just that is found [here](https://github.com/single-spa/single-spa-examples/blob/master/src/single-spa-examples.js#L3) and [here](https://github.com/single-spa/single-spa-examples/blob/master/src/navbar/navbar.app.js).\\n\\nWhile you are verifying that everything is working, keep in mind that each application goes through five phases:\\n\\n<img src=\\"https://cdn-images-1.medium.com/max/1600/1*utKlcxBkDXfQAQR52B0hAA.png\\" alt=\\"an applications\'s lifecycle\\" />\\n\\nConclusion\\n\\nAs you get your feet wet, you\u2019ll probably run into some (hopefully small) hiccups setting things up. When this tutorial is not enough, there are other resources on [Github](https://github.com/single-spa/single-spa) and here in the [docs](/docs/building-applications).\\n\\nSingle-spa is still a relatively new thing, and we\u2019d love to hear your feedback and questions. We welcome contributions from everyone.\\n\\nIf you\u2019re excited about the possibilities, feel free to contact me on [twitter (@joelbdenning)](https://twitter.com/Joelbdenning). And if you are not excited, then still feel free to contact me, but only after you leave some nasty comments :)"},{"id":"/2016/02/26/a-case-for-soa-in-the-browser","metadata":{"permalink":"/blog/2016/02/26/a-case-for-soa-in-the-browser","source":"@site/blog/2016-02-26-a-case-for-soa-in-the-browser.md","title":"A Case for SOA in the Browser","description":"So you are a web-developer. You write a lot of JavaScript. You have a large single-page application (SPA) with features to add and bugs to maintain. Over time the application grows in size and complexity. It becomes more difficult to modify one portion of the SPA without breaking another portion.","date":"2016-02-26T00:00:00.000Z","formattedDate":"February 26, 2016","tags":[],"readingTime":5.975,"hasTruncateMarker":false,"authors":[{"name":"Bret Little","url":"https://twitter.com/little_bret","imageURL":"https://pbs.twimg.com/profile_images/950593946178080768/eaNp6p-u_400x400.jpg"}],"frontMatter":{"title":"A Case for SOA in the Browser","author":"Bret Little","authorURL":"https://twitter.com/little_bret","authorImageURL":"https://pbs.twimg.com/profile_images/950593946178080768/eaNp6p-u_400x400.jpg"},"unlisted":false,"prevItem":{"title":"A step-by-step guide to single-spa","permalink":"/blog/2016/12/16/a-step-by-step-guide-to-single-spa"}},"content":"So you are a web-developer. You write a lot of JavaScript. You have a large single-page application (SPA) with features to add and bugs to maintain. Over time the application grows in size and complexity. It becomes more difficult to modify one portion of the SPA without breaking another portion.\\n\\nThe company is growing and you are looking for ways to scale the team and code-base. You add unit tests. You add a linter. You add continuous integration. You modularize the code with ES2015 modules, webpack, and npm. Eventually you even introduce new, independent SPAs with each SPA being owned and deployed by independent squads. Congratulations, you have successfully introduced service-oriented architecture on the front-end, or have you?\\n\\n## What is Service-oriented Architecture?\\n\\nThe fundamental concept behind service-oriented architecture is a service. A service is an isolated piece of code which can only be interacted with through its API. Unlike a shared library, a service itself can be deployed independently of its consumers. Think of a back-end API. The API is the service and the browser is the consumer. The API is deployed independently of the front-end application. There is also only one deployed version of the API available at a URL.\\n\\nContrast a service to a shared library. A shared library is a piece of code that is bundled and deployed with your code. For example, libraries such as Express, Lodash, and React are all shared libraries included in your application\u2019s distributable. Upgrading a version of a shared library requires a new deployment of that distributable.\\n\\nService-oriented architecture is an approach to building software where the application is composed of many independent and isolated services. Those services are independently deployable, generally non-versioned, and auto discoverable.\\n\\n## Why Service-oriented Architecture on the Front-end?\\n\\nThe benefits of SOA can be illustrated with this real life example from Canopy. At Canopy we have multiple single page applications. The first application is external to the customers and the second is internal, yet both applications share common functionality. That functionality includes among other things, authentication and error logging.\\n\\n<img src=\\"https://cdn-images-1.medium.com/max/1600/1*itLASVdD-5a3fm56hfltYQ.png\\"\\n     alt=\\"cdn-images-1\\"\\n/>\\n\\n<p style={{color: \'gray\', fontSize: \'15px\', fontStyle: \'italic\'}}>Shared libraries between two separate applications. <strong>App 1</strong> depends upon shared libs <strong>a</strong>, <strong>b</strong>, and <strong>c</strong>. <strong>App 2</strong> depends upon only shared libs <strong>a</strong> and <strong>b</strong>.</p>\\n\\nOverall the design looks good. The code is modularized and shared. The complexities arrive when we start to upgrade the code to different versions. For example, after a short period of time, <strong>App 2</strong> (being internal only) is upgraded to a new beta version of the shared lib <strong>b</strong>. Because the shared <strong>a</strong> also depends upon <strong>b</strong> (and we don\u2019t want multiple versions of <strong>b</strong> bundled) we also create a new version of <strong>a</strong>. This one change causes a rebuild and deploy of three separate pieces of code: <strong>App 2</strong> and shared libs <strong>a</strong> and <strong>b</strong>. Our dependency structure is no longer quite so simple.\\n\\n<img src=\\"https://cdn-images-1.medium.com/max/1600/1*T5YHqkoZApSvC32jVS0osw.png\\"\\n     alt=\\"cdn-images-2\\"\\n/>\\n\\n<p style={{color: \'gray\', fontSize: \'15px\', fontStyle: \'italic\'}}>In reality, a duplicate instance of lib <strong>a</strong> and <strong>b</strong> exist in both apps. Each app does not point to the same instance of the shared libraries, even when they are the same version. This is more noticeable when the shared libraries have separate versions.</p>\\n\\nNow imagine a bug in both versions of shared lib <strong>b</strong>. In order to fix the problem, you will have to republish both versions of <strong>a</strong> and <strong>b</strong> as well as <strong>c</strong>. Also <strong>App 1</strong> and <strong>App 2</strong> will have to be re-deployed. That is five new versions to publish and two apps to redeploy, all to fix one bug. All downstream dependencies have to be redeployed when a single library is changed. This is deploy dependency hell.\\n\\nService oriented architecture avoids these problems in a couple ways. Instead of bundling common dependencies, common code is shared through independent services. Services are not bundled, but rather loaded at run time. This also means that front-end services are not versioned (just like a back-end API). Both <strong>App 1</strong> and <strong>App 2</strong> load the exact same code for a front-end service.\\n\\n## Introducing sofe\\n\\nBuilt upon the new ECMAScript module specification, sofe is a JavaScript library that enables independently deployable JavaScript services to be retrieved at run-time in the browser. Because the new module specification isn\u2019t available within today\u2019s browsers, sofe relies upon [System.js](https://github.com/systemjs/systemjs) to load services at run-time.\\n\\nYou can load a sofe service either with static or asynchronous imports.\\n\\n```js\\n// Static imports\\nimport auth from \\"auth-service!sofe\\";\\nconst user = auth.getLoggedInUser();\\n// Asynchronous imports\\nSystem.import(\\"auth-service!sofe\\").then((auth) => auth.getLoggedInUser());\\n```\\n\\nThe real power behind sofe is that services are resolved at run-time, making them unversioned. If <strong>auth-service</strong> is redeployed, it is immediately made available to all upstream dependencies. The above scenario becomes much easier to resolve because there is only one version of each shared library as services. This is powerful because it allows you to deploy once, update everywhere. Also because the code is loaded at run-time, we can also enable developer tools to override what service is loaded into your application. Or in other words, you can test code on production without actually deploying to production.\\n\\n<img src=\\"https://cdn-images-1.medium.com/max/1600/1*o7IS8yKgYKSDc2w7VpyZFw.png\\"\\n     alt=\\"cdn-images-2\\"\\n/>\\n\\n<p style={{color: \'gray\', fontSize: \'15px\', fontStyle: \'italic\'}}>The common dependencies are now services that are independent from the application code. Because services are unversioned, the dependency structure is again flat. Each service can individually be deployed and be available to every upstream dependency.</p>\\n\\nObviously not all front-end code should be a service. Services have their own challenges. Specifically your code has to stay backwards compatible. But code can\u2019t always be backwards compatible. Sometimes there needs to be breaking changes. The same problem exists for back-end services. A back-end API has to stay backwards compatible. Breaking changes on the back-end are generally solved by either creating an entirely new (versioned) API or implementing feature toggles within the API itself. The same solution applies to sofe services. An entirely new sofe service can be deployed or feature toggles can exist inside the front-end service. However it is solved, the key point is that services exist outside your application within their own distributable.\\n\\nAnother potential problem for sofe services is performance. Because they are loaded at run-time, performance can become a concern if you synchronously load too many services during bootstrap. Performance degradation can be mitigated by asynchronously loading larger services after the application bootstraps. Despite these challenges, there are many benefits to services on the front-end. The most exciting thing about sofe is there is now an option for services in the browser. You can decide what should and shouldn\u2019t be a service.\\n\\nGetting started with sofe requires only System.js. But to help you get started we have built sofe to work with a variety of technologies, including webpack, Babel, jspm, and the Chrome Developer Tools. Sofe is also actively used in production at Canopy Tax. We would love feedback on sofe and a number of open source projects that have been built around it. As you approach your next front-end project or look to improve your existing app, consider how it might benefit from service oriented architecture.\\n\\nRead more about how to get started with sofe [here](https://github.com/CanopyTax/sofe)."}]}')}}]);